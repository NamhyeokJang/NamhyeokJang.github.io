{"pages":[],"posts":[{"title":"Hexo Tips","text":"Hexo 블로그를 시작하면서 알게된 몇 가지 팁입니다. 더보기 설정포스팅하면 첫 화면에 작성한 글 전부가 다 보입니다.글을 작성할 때 중간에 &lt;!-- more --&gt;을 삽입해주면, 첫 화면에서 중간에 잘려 보이게 됩니다. 썸네일 및 커버 설정블로그를 보면 글만 있다면 뭔가 아쉽다는 생각이 듭니다. cover와 thumbnail에 이미지 경로를 넣어주면 됩니다. 썸네일도 적용됩니다. 이미지 중간 정렬기본적으로 이미지를 삽입하기 위한 Markdown 문법 ![Text](/Image_Path “Alt Text&quot;) 이미지가 작을 경우 왼쪽으로 치우쳐지는 문제가 있습니다.해결방법은 다양한데, 가장 쉬운방법을 소개합니다. ![test](/ImagePath?style=centerme &quot;test&quot;) /themes/icarus/source/css/style.styl에 아래와 같이 코드를 추가 해주면 가운데 정렬이 됩니다. Markdown에 이미지 직접 삽입하기Hexo로 글을 작성하면서 이미지를 저장하고, 경로 설정해주는 것이 귀찮은 일입니다.이를 간단하게 해결할 수 있는데, 이미지를 base64로 인코딩해주면 해결됩니다.이미지를 base64로 인코딩하게 되면 data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAjUAA..... 크기에 따라서 엄청난 길이의 string으로 바꿀 수 있는데, 이를 MarkDown에 그대로 삽입하면 됩니다. ![usr](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAjUAA.....) 별도 이미지 파일을 관리하지 않고 md파일 하나로 이미지와 글을 관리할 수 있게 됩니다. 실제로 인코딩해주는 사이트도 있습니다.여기에서 테스트해보면 됩니다. 저는 그래서 글을 작성할 수 있는 에디터를 만들었습니다.실제로 이미지를 복붙하면 바로 base64로 인코딩해서 넣어줍니다.에디터는 여기에서 확인할 수 있습니다.","link":"/2020/10/24/Hexo-Tips/"},{"title":"[Hexo] Github 블로그 시작하기","text":"예전부터 github page로 블로그를 개설해보고자 했는데, 최근에서야 개설하게 되었습니다.이번에 개설하면서 정리하고자 포스팅합니다. Hexo란?hexo란 정적 웹 사이트 생성기입니다. 일반적으로 Markdown(.md)을 사용해서 글을 작성합니다.또한 theme를 다운받아서 적용할 수 도 있습니다.이와 비슷한 것으로 jekyll, gatsby 등이 있습니다. 왜 Hexo?위에 언급한 jekyll과 gatsby와 비교하자면, jekyll은 ruby기반으로 구현되어 있다보니, 제가 ruby를 모르기 때문에 혹여나 수정이 필요할 때 수정하기 어렵다는 문제와 글이 많아지면 build가 오래걸린다는 이야기가 많습니다.gastby는 react와 graphql로 구현할 수 있어서 제가 원하는대로 만들 수 있다는 장점이 있지만, 직접 구현해야되는 부분이 많아서 포기했습니다.(테마가 존재하지만 부실합니다.)Hexo_Theme에서 보면 알겠지만, 굉장히 많은 테마가 존재합니다. 디자인 또한 다양합니다. 굳이 직접 개발하지 않아도 예쁜 블로그를 구현할 수 있습니다. Github Page 시작하기Hello World먼저 github page를 구현해보겠습니다.먼저 github에 repository를 먼저 생성해줍니다.repository은 USERNAME.github.io로 생성해줍니다.USERNAME은 본인은 username을 사용해주시면 됩니다. 생성이 되었다면 terminal을 이용해서 clone해줍니다. git clone https://github.com/username/username.github.io Hello World를 보여주는 웹 페이지를 띄어봅시다.방금 clone하면 username.github.io라는 폴더가 생겼을 것입니다. cd username.github.ioecho &quot;Hello World&quot; &gt; index.html# pushgit add . or git add --allgit commit -m &quot;initial Commit&quot;git push origin -u origin master 1~2분 뒤에 https://USERNAME.github.io에 접속하면, Hello World가 보이는 웹페이지를 확인할 수 있습니다. Hexo 시작하기Hexo는 nodejs기반이기 때문에 nodejs가 설치되어 있어야합니다. (10.13이상, 12.0 추천)설치되어있다고 가정하고 진행하겠습니다. Hexo-cliHexo의 장점 중 하나가 한글 문서를 제공합니다. Hexo-cli를 설치하겠습니다. npm install -g hexo-cli clone했던 username.github.io 디렉토리에서 hexo를 만들어줍니다. cd username.github.iohexo init . 설치가 되었으면 실행해봅니다. # hexo 정적 웹 생성hexo g# hexo dev server runhexo s http://localhost:4000로 접속하면 블로그가 생성된 것을 확인할 수 있습니다. Hexo 설정_config.yml파일을 수정해서 site의 정보를 수정할 수 있습니다.몇 가지 설정을 알아보겠습니다. 사이트의 가장 기본적인 정보를 수정할 수 있는 곳입니다.이 부분은 꼭 수정해줍시다. 웹사이트의 url경로를 결정해주는 곳입니다. Hexo 글 작성하기hexo-cli를 통해서 간단한 명령어로 post를 생성할 수 있습니다. # Post 생성hexo new &quot;New Post&quot;# Draft 성성hexo new draft &quot;New Draft&quot;# Draft를 Post로 변경hexo publish &quot;Draft&quot; draft는 초안 개념입니다. 렌더링이 되지 않기 때문에 중간 중간 작업할 수 있습니다. scaffoldshexo에는 scaffolds라는 폴더에는 draft.md, post.md, page.md가 존재합니다.이 파일은 템플릿같은 개념입니다.필요에 따라서 템플릿을 만들어두시면, 작성할 때 편하게 작업할 수 있습니다. 테마 적용하기이제 테마를 적용해봅시다.Hexo에는 많은 테마를 제공하고 있습니다. 글 작성 기준으로 325개의 테마가 있습니다.제공하는 테마는 여기에서 확인할 수 있습니다.기능은 거의 비슷하니 본인이 마음에 드는 테마를 적용하면 됩니다.저는 그 중에서도 icarus테마를 적용해보겠습니다. icarus 테마 설치icarus테마를 themes/icarus경로로 clone해 받아줍니다. cd username.github.iogit clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 설치가 되었다면 icarus로 적용해줍시다._config.yml에 theme을 icarus로 수정해줍니다. 다시 hexo g를 합니다. 에러가 발생할텐데, icarus에 필요한 package가 설치되어 있지 않기 때문입니다.설치해줍시다. npm install --save bulma-stylus@0.8.0 hexo-renderer-inferno@^0.1.3 hexo-component-inferno@^0.10.1 inferno@^7.3.3 inferno-create-element@^7.3.3oryarn add bulma-stylus@0.8.0 hexo-renderer-inferno@^0.1.3 hexo-component-inferno@^0.10.1 inferno@^7.3.3 inferno-create-element@^7.3.3 설치가 다 되고 다시 hexo g하면 정상적으로 동작합니다.hexo s로 페이지를 확인해봅시다. icarus 설정_config.icarus.yml이란 파일이 생겼을 것입니다.이 파일이 icarus의 전반적인 설정파일입니다.주석으로 설명이 잘 되어있기 때문에 큰 어려움이 없지만, 막상 하고자하면 어려우니 간단하게 살펴보겠습니다. 기본적인 meta 데이터를 설정해주는 곳입니다. navbar와 footer를 설정해주는 곳입니다.아마 블로그의 about으로 갈려고 하면 에러가 발생할 텐데, page가 없어서 그렇습니다. hexo new Page &quot;about&quot; 생성해주거나, 지우면 됩니다. sidebar의 position을 세팅하는 것입니다.sticky가 true라면 사용자가 스크롤링 했을 때 같이 따라 내려옵니다.false면 상단에 고정됩니다. 처음 icarus를 실행하면, 이것저것 있는게 많아 지저분하다 생각이 듭니다.사이드에 띄어져 있는 것들이 대부분 widget인데 필요한 것만 골라서 사용하시면 됩니다.position으로 왼쪽/오른쪽을 설정할 수 있습니다. github에 deploy하기필요한 package를 설치해줍니다. npm install hexo-deployer-git --saveoryarn add hexo-deployer-git _config.yml파일 하단에 deploy부분을 수정해줍니다. deploy: type: git repo: https://github.com/username/username.github.io.git branch: master 이제 배포하면 됩니다. hexo ghexo deploy 1~2분 뒤에 접속하면 hexo로 만든 블로그가 확인됩니다.","link":"/2020/10/24/Hexo-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"[Javascript] sort()에 대해서","text":"이 포스트는 자바스크립트의 sort()에 관한 내용입니다. sort()자바스크립트를 사용하면서 정렬을 하기 위해서 sort()를 주로 사용합니다.최근 코딩테스트 준비로 알고리즘 공부를 하면서, 종종 sort()가 제대로 동작되지 않는 경우가 있었습니다.주로 숫자 배열을 정렬할 때 였는데,이는 제가 그 동안 sort()에 대해 알지 못하고 쓴 결과였습니다. const arr = [1, 2, 73, 13, 43, 31, 32, 68, 768, 547];arr.sort();// return [ 1, 13, 2, 31, 32, 43, 547, 68, 73, 768 ] sort()는 기본적으로 자바스크립트에 내장되어 제공되는 함수입니다. sort() 메서드는 배열의 요소를 적절한 위치에 정렬한 후 그 배열을 반환합니다. 정렬은 stable sort가 아닐 수 있습니다. 기본 정렬 순서는 문자열의 유니코드 코드 포인트를 따릅니다. sort()는 비교함수를 명시하지 않으면 String의 유니코드 비교입니다.그러니 2자리 이상의 숫자 비교가 제대로 나오지 않았던 것입니다. 그래서 비교할 경우 const arr = [1, 2, 73, 13, 43, 31, 32, 68, 768, 547];arr.sort((a, b) =&gt; a - b);// return [ 1, 2, 13, 31, 32, 43, 68, 73, 547, 768 ] 비교함수를 명시해주어야 제대로 된 숫자 정렬이 됩니다.","link":"/2020/10/31/Javascript%EC%9D%98-sort/"},{"title":"[WSL]NVM을 이용하여 node 설치","text":"nvm으로 node를 설치하겠습니다. NVM이란Node Version Manager의 약자로 여러 노드 버전을 사용할 경우 버전을 관리할 수 있습니다.여기에서 자세한 내용을 확인할 수 있습니다. NVM 설치curl을 이용하여 설치해줍니다. # curl 설치apt install curl# nvm 다운curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash 환경변수를 설정해주어야 제대로 동작되고 사용할 수 있습니다.프로파일파일(~/.bash_profile, ~/.zshrc, ~/.profile, or ~/.bashrc)을 수정해주어야 합니다.사용하는 환경에 맞춰서 파일을 수정해주시면 됩니다. 저 같은 경우에는 zsh을 사용하고 있기 때문에.zshrc의 맨 마지막에 아래 코드를 추가해줍니다. export NVM_DIR=&quot;$([ -z &quot;${XDG_CONFIG_HOME-}&quot; ] &amp;&amp; printf %s &quot;${HOME}/.nvm&quot; || printf %s &quot;${XDG_CONFIG_HOME}/nvm&quot;)&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm node 설치nvm install node 최신 버전으로 설치가 됩니다.","link":"/2020/10/28/NVM%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-node-%EC%84%A4%EC%B9%98/"},{"title":"Typescript로 개발하기","text":"Typescript 공부하면서 개발하기 위한 간단한 세팅 정리 시작하기디렉토리를 생성해준 후에 npm init을 해줍니다. mkdir typescript-tutorialcd typescript-tutorialnpm init -y Dependencies 추가Typescript개발을 위한 package를 설치해줍니다. yarn add -D @types/node typescript ts-node [@types/node] nodejs 타입을 추가해줍니다. [ts-node] .ts파일을 실행시킬 수 있습니다. [typescript] typescript 필수 패키지 tsconfig.json 생성npx tsconfig.json tsconfig.json은 react, react-native, node 세 종류가 있는데, 필요한 것을 추가해주면 됩니다. tsconfig.json은 typescript project의 root 디렉토리임을 나타내며, root files과 컴파일 옵션을 설정합니다.입력 파일 없이 tsc를 호출하면 컴파일러는 현재 디렉토리에서부터 시작하여 상위 디렉토리 체인으로 tsconfig.json 파일을 검색합니다 js로 컴파일하여 실행하기ts-node를 이용하여 .ts파일을 실행할 수 있지만, 실행속도가 굉장히 느립니다.그래서 js파일로 컴파일하고 실행합니다.이때 사용하는게 tsc의 watch기능인데, ts파일의 변화를 감지하고 실시간으로 js파일로 컴파일해줍니다. &quot;scripts&quot;: { &quot;watch&quot;: &quot;tsc -w&quot;} 그럼 컴파일된 js파일을 실행하면 좀더 쾌적하게 개발할 수 있습니다. nodemon실시간으로 js파일로 컴파일을 하도록 구성했으니 코드가 변하면 자동으로 변경된 코드가 실행되도록 설정하겠습니다. yarn add -D nodemon js로 컴파일된 코드는 default로 dist디렉토리에 생성됩니다. &quot;scripts&quot;: { &quot;watch&quot;: &quot;tsc -w&quot;, &quot;start&quot;: &quot;node dist/index.js&quot;, &quot;start-ts&quot;: &quot;ts-node src/index.ts&quot;, &quot;dev&quot;: &quot;nodemon dist/index.js&quot;, &quot;dev-ts&quot;: &quot;nodemon --exec ts-node src/index.ts&quot;} 최종 실행 script입니다.","link":"/2020/12/12/Typescript%EB%A1%9C-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0/"},{"title":"WSL2 메모리이슈","text":"wsl2이 나온지도 꽤 지났습니다.기존에 비해서 파일 입출력 속도가 20배 이상 빨라지고, gpu도 사용가능합니다.원래 예전부터 wsl2로 갈아탈까 고민했었지만 세팅해야될게 많아서 미루고 있다가 이번에 갈아타고자 했습니다.그런데 꽤 치명적인 이슈가 있어서 포스팅합니다. WSL2 vmmem의 미친듯한 램 점유율기존에 이미 wsl을 사용하고 있었기 때문에 이것저것 프로그램이 많이 설치되어 있는 상태였습니다.wsl2로 변환하는데도 시간이 굉장이 오래걸렸습니다.더 큰 문제는 변환하고서 사용하는데 급격하게 컴퓨터가 느려지는데, 관리자 창을 열어보니 램이 80%이상을 vmmem이 차지하고 있었습니다. 찾아보니 이미 많은 wsl2사용자들이 겪는 문제였습니다.일반적으로 docker사용으로 겪는 이슈인 듯합니다. 해결방법해결하기 위해서 이것저것 찾아봤는데, WSL2이 갖는 문제라 자체적으로 해결할 방법은 없는 듯합니다.그래서 찾아보니 가장 확실한 방법은 wsl2의 메모리를 강제로 할당하는 방법입니다. C:\\Users\\사용자에 .wslconfig파일을 생성해서 아래 코드를 작성해주면 됩니다. [wsl2]memory=6GBswap=0 세팅하고 wsl2를 다시 재부팅해주면 메모리가 6GB로 설정되있음을 확인할 수 있습니다.","link":"/2020/10/24/WSL2-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%B4%EC%8A%88/"},{"title":"[프로그래머스] 가장큰정사각형찾기","text":"1와 0로 채워진 표(board)가 있습니다. 표 1칸은 1 x 1 의 정사각형으로 이루어져 있습니다. 표에서 1로 이루어진 가장 큰 정사각형을 찾아 넓이를 return 하는 solution 함수를 완성해 주세요. (단, 정사각형이란 축에 평행한 정사각형을 말합니다.) 예를 들어|1 |2 |3| 4||—|—|—|—||0 |1 |1| 1||1 |1 |1| 1||1 |1 |1| 1||0 |0 |1| 0|가 있다면 가장 큰 정사각형은|1 |2 |3| 4||—|—|—|—||0| 1| 1| 1||1| 1| 1| 1||1| 1| 1| 1||0| 0| 1| 0|가 되며 넓이는 9가 되므로 9를 반환해 주면 됩니다. 제한사항 표(board)는 2차원 배열로 주어집니다. 표(board)의 행(row)의 크기 : 1,000 이하의 자연수 표(board)의 열(column)의 크기 : 1,000 이하의 자연수 표(board)의 값은 1또는 0으로만 이루어져 있습니다. 입출력 예 board answer [[0,1,1,1],[1,1,1,1],[1,1,1,1],[0,0,1,0]] 9 [[0,0,1,1],[1,1,1,1]] 4 입출력 예 설명입출력 예 #1위의 예시와 같습니다. 입출력 예 #2|1|2|3|4||—|—|—|—|| 0 | 0 | 1 | 1 || 1 | 1 | 1 | 1 | 풀이표로 그림을 그려보면서 접근하면 된다.예제1같은 경우|1 |2 |3| 4||—|—|—|—||0 |1 |1| 1||1 |1 |1| 1||1 |1 |1| 1||0 |0 |1| 0|각 한칸이 곧 넓이이고 모서리이다. 각 한칸은 자신의 위의 칸, 왼쪽 칸, 대각선에 있는 사각형에 영향을 받는다. 곧 board[i][j]는 board[i-1][j], board[i][j-1], board[i-1][j-1]에 영향을 받는다.board[i][j]의 제곱이 곧 정사각형의 넓이가 된다.|1 |2 |3| 4||—|—|—|—||0 |1 |1| 1||1 |1 |2| 2||1 |2 |2| 3||0 |0 |1| 0| board[i][j]는 board[i-1][j], board[i][j-1], board[i-1][j-1]의 최소값에 1을 더한 값이다.그리고 가로나 세로가 1인 경우에는 최대 넓이가 1이기 때문에 예외처리 해준다. 코드function solution(board) { let max = 0 if (board.length &lt; 2 || board[0].length &lt; 2) { for (let i = 0; i &lt; board.length; i++) { for (let j = 0; j &lt; board[i].length; j++) { if (board[i][j] === 1) { return 1 } } } } for (let i = 1; i &lt; board.length; i++) { for (let j = 1; j &lt; board[i].length; j++) { if (board[i][j] === 1) { board[i][j] = Math.min(board[i - 1][j], board[i][j - 1], board[i - 1][j - 1]) + 1 if (max &lt; board[i][j]) { max = board[i][j] } } } } return Math.pow(max, 2)}","link":"/2020/10/24/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%A5%E1%84%89%E1%85%B3-%E1%84%80%E1%85%A1%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%8F%E1%85%B3%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%89%E1%85%A1%E1%84%80%E1%85%A1%E1%86%A8%E1%84%92%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A1%E1%86%BD%E1%84%80%E1%85%B5/"},{"title":"[프로그래머스] 수식최대화","text":"IT 벤처 회사를 운영하고 있는 라이언은 매년 사내 해커톤 대회를 개최하여 우승자에게 상금을 지급하고 있습니다.이번 대회에서는 우승자에게 지급되는 상금을 이전 대회와는 다르게 다음과 같은 방식으로 결정하려고 합니다. 해커톤 대회에 참가하는 모든 참가자들에게는 숫자들과 3가지의 연산문자(+, -, ) 만으로 이루어진 연산 수식이 전달되며, 참가자의 미션은 전달받은 수식에 포함된 연산자의 우선순위를 자유롭게 재정의하여 만들 수 있는 가장 큰 숫자를 제출하는 것입니다.단, 연산자의 우선순위를 새로 정의할 때, 같은 순위의 연산자는 없어야 합니다. 즉, + &gt; - &gt; * 또는 - &gt; * &gt; + 등과 같이 연산자 우선순위를 정의할 수 있으나 +, &gt; - 또는 * &gt; +,-처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다. 수식에 포함된 연산자가 2개라면 정의할 수 있는 연산자 우선순위 조합은 2! = 2가지이며, 연산자가 3개라면 3! = 6가지 조합이 가능합니다.만약 계산된 결과가 음수라면 해당 숫자의 절댓값으로 변환하여 제출하며 제출한 숫자가 가장 큰 참가자를 우승자로 선정하며, 우승자가 제출한 숫자를 우승상금으로 지급하게 됩니다. 예를 들어, 참가자 중 네오가 아래와 같은 수식을 전달받았다고 가정합니다.&quot;100-200*300-500+20&quot; 일반적으로 수학 및 전산학에서 약속된 연산자 우선순위에 따르면 더하기와 빼기는 서로 동등하며 곱하기는 더하기, 빼기에 비해 우선순위가 높아 * &gt; +,- 로 우선순위가 정의되어 있습니다.대회 규칙에 따라 + &gt; - &gt; * 또는 - &gt; * &gt; + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,* &gt; - 또는 * &gt; +,- 처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다.수식에 연산자가 3개 주어졌으므로 가능한 연산자 우선순위 조합은 3! = 6가지이며, 그 중 + &gt; - &gt; * 로 연산자 우선순위를 정한다면 결괏값은 22,000원이 됩니다.반면에 * &gt; + &gt; - 로 연산자 우선순위를 정한다면 수식의 결괏값은 -60,420 이지만, 규칙에 따라 우승 시 상금은 절댓값인 60,420원이 됩니다. 참가자에게 주어진 연산 수식이 담긴 문자열 expression이 매개변수로 주어질 때, 우승 시 받을 수 있는 가장 큰 상금 금액을 return 하도록 solution 함수를 완성해주세요. 제한사항 expression은 길이가 3 이상 100 이하인 문자열입니다. expression은 공백문자, 괄호문자 없이 오로지 숫자와 3가지의 연산자(+, -, *) 만으로 이루어진 올바른 중위표기법(연산의 두 대상 사이에 연산기호를 사용하는 방식)으로 표현된 연산식입니다. 잘못된 연산식은 입력으로 주어지지 않습니다. 즉, “402+-561*”처럼 잘못된 수식은 올바른 중위표기법이 아니므로 주어지지 않습니다. expression의 피연산자(operand)는 0 이상 999 이하의 숫자입니다. 즉, “100-2145*458+12”처럼 999를 초과하는 피연산자가 포함된 수식은 입력으로 주어지지 않습니다. “-56+100”처럼 피연산자가 음수인 수식도 입력으로 주어지지 않습니다. expression은 적어도 1개 이상의 연산자를 포함하고 있습니다. 연산자 우선순위를 어떻게 적용하더라도, expression의 중간 계산값과 최종 결괏값은 절댓값이 263 - 1 이하가 되도록 입력이 주어집니다. 같은 연산자끼리는 앞에 있는 것의 우선순위가 더 높습니다. 입출력 예 expression result “100-200*300-500+20” 60420 “506-32” 300 입출력 예 설명입출력 예 #1* &gt; + &gt; - 로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다.연산 순서는 아래와 같습니다. 100-200*300-500+20 100-(200*300)-500+20 100-60000-(500+20) (100-60000)-520 (-59900-520) -60420따라서, 우승 시 받을 수 있는 상금은 |-60420| = 60420 입니다. 입출력 예 #2- &gt; * 로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다.연산 순서는 아래와 같습니다.(expression에서 + 연산자는 나타나지 않았으므로, 고려할 필요가 없습니다.) 506-32 50*(6-3)*2 (50*3)*2 150*2 300따라서, 우승 시 받을 수 있는 상금은 300 입니다. 풀이주어진 expression을 연산할 수 있도록 split해준다. 그리고 expression에 있는 operator기준으로 우선순위를 정해준다.구해진 우선순위 토대로 하나씩 연산해주면 된다. operator는 반드시 순자 사이에 있기 때문에 operator의 index를 구하고 앞 뒤의 숫자를 연산해준 다음 그 자리에 넣어주면 된다. 이 때 string을 연산할 수 있는 eval을 써주면 쉽게 연산할 수 있다.그렇게 구한 값들을 절대값을 해준다음 가장 큰 값을 리턴해주면 된다. 코드function solution(expression) { let numbers = expression.split(/[-+*]/gi) let operators = expression.split(/[0-9]/gi).filter(x =&gt; x !== '') let data = [] for (let i = 0; i &lt; numbers.length; i++) { data.push(numbers[i]) data.push(operators[i]) } data.pop() const oper = Array(...new Set(operators)) const pior = oper.map((x, index) =&gt; { let temp = [...oper] temp.splice(index, 1) return [[x, temp[0], temp[1]], [x, temp[1], temp[0]]] }).flat() const results = pior.map(x =&gt; { let exp = [...data] let oper = 0 while (exp.length !== 1) { if (!exp.includes(x[oper])) { oper++ } const operIndex = exp.indexOf(x[oper]) if (operIndex &lt; 0) { continue } exp.splice(operIndex - 1, 3, eval(`${exp[operIndex - 1]}${exp[operIndex]}${exp[operIndex + 1]}`)) if (exp.length &lt;= 1) { return exp } } return exp }) return Math.max.apply(null, results.flat().map(x =&gt; Math.abs(x)))}","link":"/2020/10/24/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%A5%E1%84%89%E1%85%B3-%E1%84%89%E1%85%AE%E1%84%89%E1%85%B5%E1%86%A8%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A2%E1%84%92%E1%85%AA/"},{"title":"[프로그래머스] 124나라의 숫자","text":"124 나라가 있습니다. 124 나라에서는 10진법이 아닌 다음과 같은 자신들만의 규칙으로 수를 표현합니다. 124 나라에는 자연수만 존재합니다. 124 나라에는 모든 수를 표현할 때 1, 2, 4만 사용합니다. 예를 들어서 124 나라에서 사용하는 숫자는 다음과 같이 변환됩니다. 10진법 124나라 10진법 124나라 1 1 6 14 2 2 7 21 3 4 8 22 4 11 9 24 5 12 10 41 자연수 n이 매개변수로 주어질 때, n을 124 나라에서 사용하는 숫자로 바꾼 값을 return 하도록 solution 함수를 완성해 주세요. 제한사항 n은 500,000,000이하의 자연수 입니다. 입출력 예 n result 1 1 2 2 3 4 4 11 풀이3진법으로 풀어내면 된다. 3진법은 0,1,2 이고 124나라는 1,2,4이다.10진수를 3으로 나누었을 때 나머지를 잘 매치시켜주면 된다. 코드function solution(n) { let answer = '' while (n &gt; 0) { if (n % 3 === 0) { answer = '4' + answer n = n / 3 - 1 } else if (n % 3 === 1) { answer = '1' + answer n = Math.floor(n / 3) } else { answer = '2' + answer n = Math.floor(n / 3) } } return answer}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-124%EB%82%98%EB%9D%BC%EC%9D%98-%EC%88%AB%EC%9E%90/"},{"title":"[프로그래머스] 2 x n 타일링","text":"가로 길이가 2이고 세로의 길이가 1인 직사각형모양의 타일이 있습니다. 이 직사각형 타일을 이용하여 세로의 길이가 2이고 가로의 길이가 n인 바닥을 가득 채우려고 합니다. 타일을 채울 때는 다음과 같이 2가지 방법이 있습니다. 타일을 가로로 배치 하는 경우 타일을 세로로 배치 하는 경우 직사각형의 가로의 길이 n이 매개변수로 주어질 때, 이 직사각형을 채우는 방법의 수를 return 하는 solution 함수를 완성해주세요. 제한사항 가로의 길이 n은 60,000이하의 자연수 입니다. 경우의 수가 많아 질 수 있으므로, 경우의 수를 1,000,000,007으로 나눈 나머지를 return해주세요. 입출력 예 n result 4 5 풀이처음에 경우의 수를 생각해보면n = 1일 때 1n = 2일 때 2n = 3일 때 3 =&gt; 1 + 2n = 4일 때 5 =&gt; 2 + 3…으로 진행된다.따라서 f(n) = f(n - 2) + f(n - 1)이므로 피보나치 수열과 유사하게 풀 수 있다. 코드function solution(n) { let arr = Array(n + 1).fill(0) arr[1] = 1 arr[2] = 2 for (let i = 3; i &lt; arr.length; i++) { let temp = arr[i - 1] + arr[i - 2] arr[i] = temp % 1000000007 } return arr[n]}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-2-x-n-%ED%83%80%EC%9D%BC%EB%A7%81/"},{"title":"[프로그래머스] 3진법 뒤집기","text":"자연수 n이 매개변수로 주어집니다. n을 3진법 상에서 앞뒤로 뒤집은 후, 이를 다시 10진법으로 표현한 수를 return 하도록 solution 함수를 완성해주세요. 제한사항n은 1 이상 100,000,000 이하인 자연수입니다. 입출력 예 n result 45 7 125 229 입출력 예 설명입출력 예 #1 답을 도출하는 과정은 다음과 같습니다.|n (10진법) |n (3진법) |앞뒤 반전(3진법)| 10진법으로 표현||—|—|—|—||45 |1200| 0021 |7|따라서 7을 return 해야 합니다. 입출력 예 #2 답을 도출하는 과정은 다음과 같습니다.|n (10진법) |n (3진법) |앞뒤 반전(3진법)| 10진법으로 표현||—|—|—|—||125| 11122| 22111 |229|따라서 229를 return 해야 합니다. 풀이javascript와 python 다르게 풀었다. javascript자바스크립트는 36진법까지 지원한다. toString을 이용하면 쉽게 3진법을 구할 수 있다.split으로 배열로 바꾸고 reverse로 뒤집은 다음 join으로 합쳐주면 된다.parseInt로 10진법으로 변환해준다. pythonpython은 2,8,16 진수만 지원하는지 직접 구현해야한다.n을 3으로 나눈 나머지가 각 자릿수가 된다.while문으로 n이 0보다 작을 때까지 순회하면서 n을 3으로 나눈 나머지를 to_three에 넣어준다.그 후에 join한 값을 10진수로 바꿔주면 된다. 구한 코드javascriptfunction solution(n) { n = n.toString(3).split('').reverse().join('') return parseInt(n, 3)} pythondef solution(n): to_three = [] while n &gt; 0: to_three.append(str(n % 3)) n = n // 3 return int(&quot;&quot;.join(to_three), 3)","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-3%EC%A7%84%EB%B2%95-%EB%92%A4%EC%A7%91%EA%B8%B0/"},{"title":"[프로그래머스] JadenCase문자열 만들기","text":"JadenCase란 모든 단어의 첫 문자가 대문자이고, 그 외의 알파벳은 소문자인 문자열입니다. 문자열 s가 주어졌을 때, s를 JadenCase로 바꾼 문자열을 리턴하는 함수, solution을 완성해주세요. 제한사항 s는 길이 1 이상인 문자열입니다. s는 알파벳과 공백문자(“ “)로 이루어져 있습니다. 첫 문자가 영문이 아닐때에는 이어지는 영문은 소문자로 씁니다. ( 첫번째 입출력 예 참고 ) 입출력 예 s return 3people unFollowed me 3people Unfollowed Me for the last week For The Last Week 풀이변환을 편하게 하기 위해서 모든 문자를 소문자로 변경해준다.단어의 앞에 숫자나 빈칸이 아니라면 대문자로 변경해준다. 코드function solution(s) { s = s.toLowerCase().split('') for (let i = 0; i &lt; s.length; i++) { if (i === 0 &amp;&amp; isNaN(s[i] / 1)) { s[i] = s[i].toUpperCase() } if (isNaN(s[i] / 1) &amp;&amp; s[i - 1] === ' ') { s[i] = s[i].toUpperCase() } } return s.join('')}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-JadenCase%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"title":"[프로그래머스] K번째수","text":"배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다. 예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면 array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다. 1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다. 2에서 나온 배열의 3번째 숫자는 5입니다.배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한사항 array의 길이는 1 이상 100 이하입니다. array의 각 원소는 1 이상 100 이하입니다. commands의 길이는 1 이상 50 이하입니다. commands의 각 원소는 길이가 3입니다. 입출력 예 array commands return [1, 5, 2, 6, 3, 7, 4] [[2, 5, 3], [4, 4, 1], [1, 7, 3]] [5, 6, 3] 입출력 예 설명[1, 5, 2, 6, 3, 7, 4]를 2번째부터 5번째까지 자른 후 정렬합니다.[2, 3, 5, 6]의 세 번째 숫자는 5입니다.[1, 5, 2, 6, 3, 7, 4]를 4번째부터 4번째까지 자른 후 정렬합니다. [6]의 첫 번째 숫자는 6입니다.[1, 5, 2, 6, 3, 7, 4]를 1번째부터 7번째까지 자릅니다. [1, 2, 3, 4, 5, 6, 7]의 세 번째 숫자는 3입니다. 풀이map으로 commands를 나누어서 계산한다.slice이용해서 array를 잘라주고 sort해준다. 코드javascriptfunction solution(array, commands) { return answer = commands.map(command =&gt; { const arr = array.slice(command[0] - 1, command[1]).sort((a, b) =&gt; a - b) return arr[command[2] - 1] })} pythondef solution(array, commands): answer = [] for command in commands: arr = sorted(array[command[0] - 1 : command[1]]) answer.append(arr[command[2] - 1]) return answer","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-K%EB%B2%88%EC%A7%B8%EC%88%98/"},{"title":"[프로그래머스] N개의 최소공배수","text":"두 수의 최소공배수(Least Common Multiple)란 입력된 두 수의 배수 중 공통이 되는 가장 작은 숫자를 의미합니다. 예를 들어 2와 7의 최소공배수는 14가 됩니다. 정의를 확장해서, n개의 수의 최소공배수는 n 개의 수들의 배수 중 공통이 되는 가장 작은 숫자가 됩니다. n개의 숫자를 담은 배열 arr이 입력되었을 때 이 수들의 최소공배수를 반환하는 함수, solution을 완성해 주세요. 제한사항 arr은 길이 1이상, 15이하인 배열입니다. arr의 원소는 100 이하인 자연수입니다.입출력 예 arr result [2,6,8,14] 168 [1,2,3] 6 풀이너무 어렵게 풀 필요없다. 두 개씩 최소공배수를 구하면서 풀이하면 쉽게 풀 수 있다. 코드function solution(arr) { arr = arr.sort().reverse() return arr.reduce((a, b) =&gt; lcm(a, b))}function lcm(a, b) { return a * b / gcd(a, b)}function gcd(a, b) { if (b === 0) return a return gcd(b, a % b)}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-N%EA%B0%9C%EC%9D%98-%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98/"},{"title":"[프로그래머스] 가운데 글자 가져오기","text":"단어 s의 가운데 글자를 반환하는 함수, solution을 만들어 보세요. 단어의 길이가 짝수라면 가운데 두글자를 반환하면 됩니다. 제한사항 s는 길이가 1 이상, 100이하인 스트링입니다. 입출력 예 s return abcde c qwer we 코드javascriptfunction solution(s) { if (s.length % 2) { return s[parseInt(s.length / 2)] } else { return `${s[s.length / 2 - 1]}${s[s.length / 2]}` }} pythondef solution(s): s_len = len(s) if s_len % 2 == 0: return s[int(s_len/2)-1:int(s_len/2)+1] return s[int(s_len/2)]","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EA%B0%80%EC%9A%B4%EB%8D%B0-%EA%B8%80%EC%9E%90-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0/"},{"title":"[프로그래머스] 가장 긴 팰린드롬","text":"앞뒤를 뒤집어도 똑같은 문자열을 팰린드롬(palindrome)이라고 합니다.문자열 s가 주어질 때, s의 부분문자열(Substring)중 가장 긴 팰린드롬의 길이를 return 하는 solution 함수를 완성해 주세요. 예를들면, 문자열 s가 abcdcba이면 7을 return하고 abacde이면 3을 return합니다. 제한사항 문자열 s의 길이 : 2,500 이하의 자연수 문자열 s는 알파벳 소문자로만 구성 입출력 예 s answer abcdcba 7 abacde 3 입출력 예 설명입출력 예 #14번째자리 ‘d’를 기준으로 문자열 s 전체가 팰린드롬이 되므로 7을 return합니다. 입출력 예 #22번째자리 ‘b’를 기준으로 aba가 팰린드롬이 되므로 3을 return합니다. 풀이먼저 팰린드롬 문자인지 체크할 수 있는 checkPel함수를 만들었다.그리고 모든 문자를 검사할 수 있게 for문 중첩으로 체크해준다.팰린드롬 문자열을 체크하는건 오래 걸리기 때문에 모든 문자를 체크해주면 시간이 걸리기 때문에최대 길이 len이하는 체크하지 않도록 넘어가는 형식으로 구현하였다. 코드function solution(s) { let len = 0 for (let i = 0; i &lt; s.length; i++) { for (let j = 0; j &lt; s.length; j++) { const str = s.slice(j, s.length - i) if (str.length === 0 || str.length &lt;= len) continue if (checkPel(str)) { if (len &lt; str.length) { len = str.length } } } } return len}function checkPel(s) { const cnt = parseInt(s.length / 2) for (let i = 0; i &lt; cnt; i++) { if (s[i] !== s[s.length - 1 - i]) { return false } } return true}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EA%B0%80%EC%9E%A5-%EA%B8%B4-%ED%8C%B0%EB%A6%B0%EB%93%9C%EB%A1%AC/"},{"title":"[프로그래머스] 같은 숫자는 싫어","text":"배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져 있습니다. 이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다. 단, 제거된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다. 예를 들면, arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다. arr = [4, 4, 4, 3, 3] 이면 [4, 3] 을 return 합니다. 배열 arr에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 solution 함수를 완성해 주세요. 제한사항배열 arr의 크기 : 1,000,000 이하의 자연수배열 arr의 원소의 크기 : 0보다 크거나 같고 9보다 작거나 같은 정수 입출력 예 arr answer [1,1,3,3,0,1,1] [1,3,0,1] [4,4,4,3,3] [4,3] 풀이for loop이 돌면서 arr의 현재 값과 answer의 마지막 요소의 값이 같지 않으면 answer에 arr의 요소를 push해준다. 코드javascriptfunction solution(arr) { const answer = [] arr.forEach(value =&gt; { if (value !== answer[answer.length - 1]) answer.push(value) }) return answer} pythondef solution(arr): answer = [] for el in arr: if answer[-1:] != [el]: answer.append(el) return answer","link":"/2020/10/23/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EA%B0%99%EC%9D%80-%EC%88%AB%EC%9E%90%EB%8A%94-%EC%8B%AB%EC%96%B4/"},{"title":"프로그래머스-구명보트","text":"무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있습니다. 예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다. 구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다. 사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요. 제한사항 무인도에 갇힌 사람은 1명 이상 50,000명 이하입니다. 각 사람의 몸무게는 40kg 이상 240kg 이하입니다. 구명보트의 무게 제한은 40kg 이상 240kg 이하입니다. 구명보트의 무게 제한은 항상 사람들의 몸무게 중 최댓값보다 크게 주어지므로 사람들을 구출할 수 없는 경우는 없습니다. 입출력 예 people limit return [70, 50, 80, 50] 100 3 [70, 80, 50] 100 3 풀이처음에 최대 2명밖에 못 탄다는 것을 못봐서, 고생했다.최대한 몸무게가 많이 나가는 사람과 몸무게가 적게 나가는 사람을 같이 태워야 적은 수의 보트를 사용한다.people을 먼저 정렬해준다.그리고 [---&gt; &lt;---]로 while문으로 진행해준다.마지막에 start와 end가 같으면 한명이 남았기 때문에 +1을 해줘야 한다. 코드function solution(people, limit) { people = people.sort((a, b) =&gt; a - b) let answer = 0 let start = 0 let end = people.length - 1 while (start &lt; end) { const sum = people[start] + people[end] if (sum &lt;= limit) { answer++ start++ end-- } else { end-- answer++ } } if (start === end) { return answer + 1 } return answer}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EA%B5%AC%EB%AA%85%EB%B3%B4%ED%8A%B8/"},{"title":"[프로그래머스] 기능개발","text":"프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다. 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다. 먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요. 제한사항 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다. 작업 진도는 100 미만의 자연수입니다. 작업 속도는 100 이하의 자연수입니다. 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다. 입출력 예 progresses speeds return [93, 30, 55] [1, 30, 5] [2, 1] [95, 90, 99, 99, 80, 99] [1, 1, 1, 1, 1, 1] [1, 3, 2] 입출력 예 설명입출력 예 #1첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다. 따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다. 입출력 예 #2모든 기능이 하루에 1%씩 작업이 가능하므로, 작업이 끝나기까지 남은 일수는 각각 5일, 10일, 1일, 1일, 20일, 1일입니다. 어떤 기능이 먼저 완성되었더라도 앞에 있는 모든 기능이 완성되지 않으면 배포가 불가능합니다. 따라서 5일째에 1개의 기능, 10일째에 3개의 기능, 20일째에 2개의 기능이 배포됩니다. 풀이모든 기능의 구현되는 진행률과 진행속도가 다르기 때문에 좀더 쉽게 접근하고자, 통일 시켜주는 작업을 먼저 한다.(100 - 현재 진행상태) / speed하면 남은 날짜들을 구할 수 있다.그리고 남은 날짜를 이용해서 구하면 되는데, 앞의 기능이 구현됬을 때 뒤의 기능 중 구현완료가 된것도 합쳐줘야 하기 때문에 while을 이용해서 찾아서 count 해주면 된다. 코드function solution(progresses, speeds) { const answer = [] let lastDate = progresses.map((progress, index) =&gt; Math.ceil((100 - progress) / speeds[index])) for (let i = 0; i &lt; lastDate.length; i++) { const currentJob = lastDate[i] let j = i + 1 let count = 1 while (currentJob &gt;= lastDate[j]) { count++ j++ i++ } answer.push(count) } return answer}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EA%B8%B0%EB%8A%A5%EA%B0%9C%EB%B0%9C/"},{"title":"[프로그래머스] 나누어 떨어지는 숫자 배열","text":"array의 각 element 중 divisor로 나누어 떨어지는 값을 오름차순으로 정렬한 배열을 반환하는 함수, solution을 작성해주세요.divisor로 나누어 떨어지는 element가 하나도 없다면 배열에 -1을 담아 반환하세요. 제한사항 arr은 자연수를 담은 배열입니다. 정수 i, j에 대해 i ≠ j 이면 arr[i] ≠ arr[j] 입니다. divisor는 자연수입니다. array는 길이 1 이상인 배열입니다. 입출력 예 arr divisor return [5, 9, 7, 10] 5 [5, 10] [2, 36, 1, 3] 1 [1, 2, 3, 36] [3,2,6] 10 [-1] 입출력 예 설명입출력 예#1arr의 원소 중 5로 나누어 떨어지는 원소는 5와 10입니다. 따라서 [5, 10]을 리턴합니다. 입출력 예#2arr의 모든 원소는 1으로 나누어 떨어집니다. 원소를 오름차순으로 정렬해 [1, 2, 3, 36]을 리턴합니다. 입출력 예#33, 2, 6은 10으로 나누어 떨어지지 않습니다. 나누어 떨어지는 원소가 없으므로 [-1]을 리턴합니다. 풀이arr의 요소가 divisor로 나누었을 때 나머지가 0이면 push해준다.answer가 비어있다면 [-1]해주고, 아니라면 sort해준다. 코드javascriptfunction solution(arr, divisor) { let answer = [] arr.forEach(value =&gt; { if (value / divisor &gt;= 1 &amp;&amp; value % divisor === 0) answer.push(value) }); return answer.length !== 0 ? answer.sort((a, b) =&gt; a - b) : [-1]} pythondef solution(arr, divisor): answer = [] for el in arr: if el % divisor == 0: answer.append(el) if len(answer) == 0: return [-1] return sorted(answer)","link":"/2020/10/23/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%82%98%EB%88%84%EC%96%B4-%EB%96%A8%EC%96%B4%EC%A7%80%EB%8A%94-%EC%88%AB%EC%9E%90-%EB%B0%B0%EC%97%B4/"},{"title":"[프로그래머스] 뉴스 클러스터링","text":"여러 언론사에서 쏟아지는 뉴스, 특히 속보성 뉴스를 보면 비슷비슷한 제목의 기사가 많아 정작 필요한 기사를 찾기가 어렵다. Daum 뉴스의 개발 업무를 맡게 된 신입사원 튜브는 사용자들이 편리하게 다양한 뉴스를 찾아볼 수 있도록 문제점을 개선하는 업무를 맡게 되었다. 개발의 방향을 잡기 위해 튜브는 우선 최근 화제가 되고 있는 카카오 신입 개발자 공채 관련 기사를 검색해보았다. 카카오 첫 공채..’블라인드’ 방식 채용 카카오, 합병 후 첫 공채.. 블라인드 전형으로 개발자 채용 카카오, 블라인드 전형으로 신입 개발자 공채 카카오 공채, 신입 개발자 코딩 능력만 본다 카카오, 신입 공채.. 코딩 실력만 본다 카카오 코딩 능력만으로 2018 신입 개발자 뽑는다 기사의 제목을 기준으로 블라인드 전형에 주목하는 기사와 코딩 테스트에 주목하는 기사로 나뉘는 걸 발견했다. 튜브는 이들을 각각 묶어서 보여주면 카카오 공채 관련 기사를 찾아보는 사용자에게 유용할 듯싶었다. 유사한 기사를 묶는 기준을 정하기 위해서 논문과 자료를 조사하던 튜브는 자카드 유사도라는 방법을 찾아냈다. 자카드 유사도는 집합 간의 유사도를 검사하는 여러 방법 중의 하나로 알려져 있다. 두 집합 A, B 사이의 자카드 유사도 J(A, B)는 두 집합의 교집합 크기를 두 집합의 합집합 크기로 나눈 값으로 정의된다. 예를 들어 집합 A = {1, 2, 3}, 집합 B = {2, 3, 4}라고 할 때, 교집합 A ∩ B = {2, 3}, 합집합 A ∪ B = {1, 2, 3, 4}이 되므로, 집합 A, B 사이의 자카드 유사도 J(A, B) = 2/4 = 0.5가 된다. 집합 A와 집합 B가 모두 공집합일 경우에는 나눗셈이 정의되지 않으니 따로 J(A, B) = 1로 정의한다. 자카드 유사도는 원소의 중복을 허용하는 다중집합에 대해서 확장할 수 있다. 다중집합 A는 원소 1을 3개 가지고 있고, 다중집합 B는 원소 1을 5개 가지고 있다고 하자. 이 다중집합의 교집합 A ∩ B는 원소 1을 min(3, 5)인 3개, 합집합 A ∪ B는 원소 1을 max(3, 5)인 5개 가지게 된다. 다중집합 A = {1, 1, 2, 2, 3}, 다중집합 B = {1, 2, 2, 4, 5}라고 하면, 교집합 A ∩ B = {1, 2, 2}, 합집합 A ∪ B = {1, 1, 2, 2, 3, 4, 5}가 되므로, 자카드 유사도 J(A, B) = 3/7, 약 0.42가 된다. 이를 이용하여 문자열 사이의 유사도를 계산하는데 이용할 수 있다. 문자열 FRANCE와 FRENCH가 주어졌을 때, 이를 두 글자씩 끊어서 다중집합을 만들 수 있다. 각각 {FR, RA, AN, NC, CE}, {FR, RE, EN, NC, CH}가 되며, 교집합은 {FR, NC}, 합집합은 {FR, RA, AN, NC, CE, RE, EN, CH}가 되므로, 두 문자열 사이의 자카드 유사도 J(&quot;FRANCE&quot;, &quot;FRENCH&quot;) = 2/8 = 0.25가 된다. 입력 형식입력으로는 str1과 str2의 두 문자열이 들어온다. 각 문자열의 길이는 2 이상, 1,000 이하이다.입력으로 들어온 문자열은 두 글자씩 끊어서 다중집합의 원소로 만든다. 이때 영문자로 된 글자 쌍만 유효하고, 기타 공백이나 숫자, 특수 문자가 들어있는 경우는 그 글자 쌍을 버린다. 예를 들어 ab+가 입력으로 들어오면, ab만 다중집합의 원소로 삼고, b+는 버린다.다중집합 원소 사이를 비교할 때, 대문자와 소문자의 차이는 무시한다. AB와 Ab, ab는 같은 원소로 취급한다. 출력 형식입력으로 들어온 두 문자열의 자카드 유사도를 출력한다. 유사도 값은 0에서 1 사이의 실수이므로, 이를 다루기 쉽도록 65536을 곱한 후에 소수점 아래를 버리고 정수부만 출력한다. 입출력 예 str1 str2 answer FRANCE french 16384 handshake shake hands 65536 aa1+aa2 AAAA12 43690 E=M*C^2 e=m*c^2 65536 풀이유사도를 구하기 위해서 str을 비교 배열로 만들어준다.조건인 합집합과 교집합으로 구한다.교집합을 구하는 부분에서 배열의 길이에 따라서 결과값이 달라질 수 있기 때문에 짧은 배열로 include로 구해주어야 한다. 코드function solution(str1, str2) { const K = 65536 str1 = genArr(str1) str2 = genArr(str2) const long = str1.length &gt; str2.length ? str1 : str2 const short = str1.length &gt; str2.length ? str2 : str1 const longLen = long.length const shortLen = short.length const inter = short.filter(x =&gt; { if (long.includes(x)) { long.splice(long.indexOf(x), 1) return true } else return false }) const sum = longLen + shortLen - inter.length if (inter.length === 0 &amp;&amp; sum === 0) return K return parseInt(inter.length / sum * K)}function genArr(string) { let result = [] string = string.toUpperCase().replace(/[^a-zA-Z]/gi, ' ') for (let i = 0; i &lt; string.length - 1; i++) { if (string[i] !== ' ' &amp;&amp; string[i + 1] !== ' ') { result.push(string[i] + string[i + 1]) } } return result.sort((a, b) =&gt; a &gt; b)}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%89%B4%EC%8A%A4-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81/"},{"title":"[프로그래머스] 두 개 뽑아서 더하기","text":"정수 배열 numbers가 주어집니다. numbers에서 서로 다른 인덱스에 있는 두 개의 수를 뽑아 더해서 만들 수 있는 모든 수를 배열에 오름차순으로 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 numbers의 길이는 2 이상 100 이하입니다. numbers의 모든 수는 0 이상 100 이하입니다. 입출력 예 numbers result [2,1,3,4,1] [2,3,4,5,6,7] [5,0,2,7] [2,5,7,9,12] 입출력 예 설명입출력 예 #1 2 = 1 + 1 입니다. (1이 numbers에 두 개 있습니다.) 3 = 2 + 1 입니다. 4 = 1 + 3 입니다. 5 = 1 + 4 = 2 + 3 입니다. 6 = 2 + 4 입니다. 7 = 3 + 4 입니다. 따라서 [2,3,4,5,6,7] 을 return 해야 합니다. 입출력 예 #2 2 = 0 + 2 입니다. 5 = 5 + 0 입니다. 7 = 0 + 7 = 5 + 2 입니다. 9 = 2 + 7 입니다. 12 = 5 + 7 입니다. 따라서 [2,5,7,9,12] 를 return 해야 합니다. 풀이numbers의 2개의 합에 대한 모든 경우의 수를 구하면 되는 문제다. 중첩 for문을 이용해서 모든 경우의 구한다. 중복된 값을 제거해준다. 값을 오름차순으로 정렬해준다. 코드javascriptfunction solution(numbers) { const temp = [] for (let i = 0; i &lt; numbers.length; i++) { for (let j = i + 1; j &lt; numbers.length; j++) { temp.push(numbers[i] + numbers[j]) } } return [...new Set(temp)].sort((a, b) =&gt; a - b)}","link":"/2020/10/23/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%91%90-%EA%B0%9C-%EB%BD%91%EC%95%84%EC%84%9C-%EB%8D%94%ED%95%98%EA%B8%B0/"},{"title":"[프로그래머스] 두 정수 사이의 합","text":"두 정수 a, b가 주어졌을 때 a와 b 사이에 속한 모든 정수의 합을 리턴하는 함수, solution을 완성하세요.예를 들어 a = 3, b = 5인 경우, 3 + 4 + 5 = 12이므로 12를 리턴합니다. 제한 조건 a와 b가 같은 경우는 둘 중 아무 수나 리턴하세요. a와 b는 -10,000,000 이상 10,000,000 이하인 정수입니다. a와 b의 대소관계는 정해져있지 않습니다. 입출력 예 a b return 3 5 12 3 3 3 5 3 12 풀이a와 b의 대소 관계가 정해져있지 않기 때문에 배열로 바꾸고 정렬해준다.for문으로 차례대로 더해주면 된다. 코드function solution(a, b) { let answer = 0 let numbers = [a, b].sort((a, b) =&gt; a - b) for (let i = numbers[0]; i &lt;= numbers[1]; i++) { answer = answer + i } return answer}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%91%90-%EC%A0%95%EC%88%98-%EC%82%AC%EC%9D%B4%EC%9D%98-%ED%95%A9/"},{"title":"[프로그래머스] 디스크 컨트롤러","text":"하드디스크는 한 번에 하나의 작업만 수행할 수 있습니다. 디스크 컨트롤러를 구현하는 방법은 여러 가지가 있습니다. 가장 일반적인 방법은 요청이 들어온 순서대로 처리하는 것입니다. 예를들어 - 0ms 시점에 3ms가 소요되는 A작업 요청- 1ms 시점에 9ms가 소요되는 B작업 요청- 2ms 시점에 6ms가 소요되는 C작업 요청 와 같은 요청이 들어왔습니다. 이를 그림으로 표현하면 아래와 같습니다.한 번에 하나의 요청만을 수행할 수 있기 때문에 각각의 작업을 요청받은 순서대로 처리하면 다음과 같이 처리 됩니다. - A: 3ms 시점에 작업 완료 (요청에서 종료까지 : 3ms)- B: 1ms부터 대기하다가, 3ms 시점에 작업을 시작해서 12ms 시점에 작업 완료(요청에서 종료까지 : 11ms)- C: 2ms부터 대기하다가, 12ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 16ms) 이 때 각 작업의 요청부터 종료까지 걸린 시간의 평균은 10ms(= (3 + 11 + 16) / 3)가 됩니다. 하지만 A → C → B 순서대로 처리하면 - A: 3ms 시점에 작업 완료(요청에서 종료까지 : 3ms)- C: 2ms부터 대기하다가, 3ms 시점에 작업을 시작해서 9ms 시점에 작업 완료(요청에서 종료까지 : 7ms)- B: 1ms부터 대기하다가, 9ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 17ms) 이렇게 A → C → B의 순서로 처리하면 각 작업의 요청부터 종료까지 걸린 시간의 평균은 9ms(= (3 + 7 + 17) / 3)가 됩니다. 각 작업에 대해 [작업이 요청되는 시점, 작업의 소요시간]을 담은 2차원 배열 jobs가 매개변수로 주어질 때, 작업의 요청부터 종료까지 걸린 시간의 평균을 가장 줄이는 방법으로 처리하면 평균이 얼마가 되는지 return 하도록 solution 함수를 작성해주세요. (단, 소수점 이하의 수는 버립니다) 제한사항 jobs의 길이는 1 이상 500 이하입니다. jobs의 각 행은 하나의 작업에 대한 [작업이 요청되는 시점, 작업의 소요시간] 입니다. 각 작업에 대해 작업이 요청되는 시간은 0 이상 1,000 이하입니다. 각 작업에 대해 작업의 소요시간은 1 이상 1,000 이하입니다. 하드디스크가 작업을 수행하고 있지 않을 때에는 먼저 요청이 들어온 작업부터 처리합니다. 입출력 예 jobs return [[0, 3], [1, 9], [2, 6]] 9 입출력 예 설명문제에 주어진 예와 같습니다. 0ms 시점에 3ms 걸리는 작업 요청이 들어옵니다. 1ms 시점에 9ms 걸리는 작업 요청이 들어옵니다. 2ms 시점에 6ms 걸리는 작업 요청이 들어옵니다. 풀이가장 적게 처리하는 방법은 가능한 짧은 process를 먼저 실행시키는 것이다.먼저 주어진 jobs을 요청시간을 먼저 정렬하고, 걸리는 시간을 정렬한다.일이 끝난 시간 currentTime에서 요청시간이 요청시간부터 완료되는데 걸리는 시간이므로, worked에 넣어준다.그리고 일이 끝났으니 다음 process를 선택해야 하는데, 요청시간이 currentTime보다 작은 것들 중에서 process가 짧은 것을 골라준다.그리고 jobs에서 제거해주고 위의 행동을 반복한다.그 중에서 요청시간이 currentTime보다 긴 경우가 있을 수 있기 때문에 예외처리해준다. 코드function solution(jobs) { const jobsLen = jobs.length jobs = jobs.sort((a, b) =&gt; a[0] - b[0] || a[1] - b[1]) let worked = [] let currentJob = null let currentTime = 0 while (jobsLen !== worked.length) { if (currentJob === null) { currentJob = jobs.shift() currentTime = currentJob[0] } if (currentTime &lt; currentJob[0]) { currentTime = currentJob[0] + currentJob[1] } else { currentTime = currentTime + currentJob[1] } worked.push(currentTime - currentJob[0]) const canWork = jobs.filter(x =&gt; x[0] &lt;= currentTime) currentJob = canWork.length !== 0 ? canWork.sort((a, b) =&gt; a[1] - b[1])[0] : jobs[0] jobs.splice(jobs.indexOf(currentJob), 1) } return parseInt(worked.reduce((acc, cur) =&gt; acc + cur) / jobsLen)}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%94%94%EC%8A%A4%ED%81%AC%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC/"},{"title":"[프로그래머스] 모의고사","text":"수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다. 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, …2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, …3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, … 1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한 조건 시험은 최대 10,000 문제로 구성되어있습니다. 문제의 정답은 1, 2, 3, 4, 5중 하나입니다. 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요. 입출력 예 answers return [1,2,3,4,5] [1] [1,3,2,4,2] [1,2,3] 입출력 예 설명입출력 예 #1 수포자 1은 모든 문제를 맞혔습니다. 수포자 2는 모든 문제를 틀렸습니다. 수포자 3은 모든 문제를 틀렸습니다. 따라서 가장 문제를 많이 맞힌 사람은 수포자 1입니다. 입출력 예 #2 모든 사람이 2문제씩을 맞췄습니다. 풀이각 학생들이 맞은 문제를 체크하는 배열을 생성한다.answer[i] === student[i % student.length]이면 학생이 정답을 맞은 것이다.높은 점수가 있는 사람을 return해준다. 코드function solution(answers) { const student1 = [1, 2, 3, 4, 5] const student2 = [2, 1, 2, 3, 2, 4, 2, 5] const student3 = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5] let count = [0, 0, 0] let result = [] for (let i = 0; i &lt; answers.length; i++) { if (student1[i % student1.length] === answers[i]) { count[0]++ } if (student2[i % student2.length] === answers[i]) { count[1]++ } if (student3[i % student3.length] === answers[i]) { count[2]++ } } let max = Math.max(...count) count.forEach((value, index) =&gt; { if (value &gt;= max) result.push(index + 1) }) return result}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC/"},{"title":"[프로그래머스] 문자열 내 p와 y의 개수","text":"대문자와 소문자가 섞여있는 문자열 s가 주어집니다. s에 ‘p’의 개수와 ‘y’의 개수를 비교해 같으면 True, 다르면 False를 return 하는 solution를 완성하세요. ‘p’, ‘y’ 모두 하나도 없는 경우는 항상 True를 리턴합니다. 단, 개수를 비교할 때 대문자와 소문자는 구별하지 않습니다. 예를 들어 s가 pPoooyY면 true를 return하고 Pyy라면 false를 return합니다. 제한사항 문자열 s의 길이 : 50 이하의 자연수 문자열 s는 알파벳으로만 이루어져 있습니다. 입출력 예 s answer pPoooyY true Pyy false 입출력 예 설명입출력 예 #1‘p’의 개수 2개, ‘y’의 개수 2개로 같으므로 true를 return 합니다. 입출력 예 #2‘p’의 개수 1개, ‘y’의 개수 2개로 다르므로 false를 return 합니다. 풀이주어진 s를 대문자로 바꾸고 배열로 만든다.filter로 p와 y의 수를 구하고 비교하여 return 코드function solution(s) { const upper = s.toUpperCase().split('') const p = upper.filter(value =&gt; value === 'P') const y = upper.filter(value =&gt; value === 'Y') return p.length === y.length}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%82%B4-p%EC%99%80-y%EC%9D%98-%EA%B0%9C%EC%88%98/"},{"title":"[프로그래머스] 문자열 내림차순으로 배치하기","text":"문자열 s에 나타나는 문자를 큰것부터 작은 순으로 정렬해 새로운 문자열을 리턴하는 함수, solution을 완성해주세요.s는 영문 대소문자로만 구성되어 있으며, 대문자는 소문자보다 작은 것으로 간주합니다. 제한사항 str은 길이 1 이상인 문자열입니다. 입출력 예 s return Zbcdefg gfedcbZ 풀이javascript 기본 메소드를 잘 조합해서 풀면 된다. split로 문자를 쪼갠다. sort로 정렬해준다. reverse로 반대로 뒤집어준다. join으로 쪼개진 알파벳을 다시 합쳐준다. 코드function solution(s) { return s.split('').sort().reverse().join('')}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%82%B4%EB%A6%BC%EC%B0%A8%EC%88%9C%EC%9C%BC%EB%A1%9C-%EB%B0%B0%EC%B9%98%ED%95%98%EA%B8%B0/"},{"title":"[프로그래머스] 베스트앨범","text":"스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 합니다. 노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다. 속한 노래가 많이 재생된 장르를 먼저 수록합니다. 장르 내에서 많이 재생된 노래를 먼저 수록합니다. 장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다. 노래의 장르를 나타내는 문자열 배열 genres와 노래별 재생 횟수를 나타내는 정수 배열 plays가 주어질 때, 베스트 앨범에 들어갈 노래의 고유 번호를 순서대로 return 하도록 solution 함수를 완성하세요. 제한사항 genres[i]는 고유번호가 i인 노래의 장르입니다. plays[i]는 고유번호가 i인 노래가 재생된 횟수입니다. genres와 plays의 길이는 같으며, 이는 1 이상 10,000 이하입니다. 장르 종류는 100개 미만입니다. 장르에 속한 곡이 하나라면, 하나의 곡만 선택합니다. 모든 장르는 재생된 횟수가 다릅니다. 입출력 예 genres plays return [classic, pop, classic, classic, pop] [500, 600, 150, 800, 2500] [4, 1, 3, 0] 입출력 예 설명classic 장르는 1,450회 재생되었으며, classic 노래는 다음과 같습니다. 고유 번호 3: 800회 재생 고유 번호 0: 500회 재생 고유 번호 2: 150회 재생 pop 장르는 3,100회 재생되었으며, pop 노래는 다음과 같습니다. 고유 번호 4: 2,500회 재생 고유 번호 1: 600회 재생 따라서 pop 장르의 [4, 1]번 노래를 먼저, classic 장르의 [3, 0]번 노래를 그다음에 수록합니다. 풀이장르별로 잘 분류해서 풀면 된다.장르를 Set을 이용하여 구한다. 그리고 각 노래를 object({id, genre, play})로 변환한다.그리고 각 장르별로 다시 object({ genre, play, songs: [] })로 변환해준다.이때 최대로 나올 수 있는 곡은 2곡이 최대이니, songs에는 play의 내림차순으로 2곡만 넣어준다.그 다음 장르 별 총 play 순으로 내림차순한 다음 각 songs의 id값만 뽑아서 return해주면 된다. 코드function solution(genres, plays) { const GENRES = Array(...new Set(genres)) let data = [] let form = [] for (let i = 0; i &lt; genres.length; i++) { data.push({ id: i, genre: genres[i], play: plays[i] }) } for (let i = 0; i &lt; GENRES.length; i++) { const filteredGenre = data.filter(x =&gt; x.genre === GENRES[i]) form.push({ genre: GENRES[i], play: filteredGenre.map(x =&gt; x.play).reduce((acc, cur) =&gt; acc + cur), songs: filteredGenre.sort((a, b) =&gt; b.play - a.play).slice(0, 2) }) } let answer = [] form.sort((a, b) =&gt; b.play - a.play).map(x =&gt; x.songs.map(x =&gt; x.id)).forEach(x =&gt; answer = [...answer, ...x]) return answer}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%B2%A0%EC%8A%A4%ED%8A%B8%EC%95%A8%EB%B2%94/"},{"title":"[프로그래머스-KAKAO 2018] 비밀지도","text":"네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다. 지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 공백(“ ) 또는벽(#”) 두 종류로 이루어져 있다. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 지도 1과 지도 2라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다. 지도 1과 지도 2는 각각 정수 배열로 암호화되어 있다. 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다. 네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라. 입력 형식입력으로 지도의 한 변 크기 n 과 2개의 정수 배열 arr1, arr2가 들어온다. 1 ≦ n ≦ 16 arr1, arr2는 길이 n인 정수 배열로 주어진다. 정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다. 출력 형식원래의 비밀지도를 해독하여 ‘#’, 공백으로 구성된 문자열 배열로 출력하라. 입출력 예제 매개변수 값 n 5 arr1 [9, 20, 28, 18, 11] arr2 [30, 1, 21, 17, 28] 출력 [“#####”,”# # #”, “### #”, “# ##”, “#####”] 매개변수 값 n 6 arr1 [46, 33, 33 ,22, 31, 50] arr2 [27 ,56, 19, 14, 14, 10] 출력 [“######”, “### #”, “## ##”, “ #### “, “ #####”, “### # “] 풀이arr에 들어있는 수를 2진법을 #으로 변환을 먼저 해준다.arr1과 arr2가 둘 중 하나라도 #이면 #이므로 바꿔준다.그렇게 변환이 끝난 배열을 다시 join으로 합쳐주면 된다. 코드function solution(n, arr1, arr2) { const toArr = (arr) =&gt; arr.map(value =&gt; { const toBin = value.toString(2).split('').reverse() const zeroArr = new Array(n).fill('0') return zeroArr.map((value, index) =&gt; { if (toBin[index]) return toBin[index] else return value }).reverse() }) const toArr1 = toArr(arr1) const toArr2 = toArr(arr2) let answer = [] for (let i = 0; i &lt; toArr1.length; i++) { let tempArr = [] for (let j = 0; j &lt; toArr2.length; j++) { if (j === 0) tempArr = [] if (toArr1[i][j] === '1' || toArr2[i][j] === '1') { tempArr.push('#') } else { tempArr.push(' ') } if (j === toArr2.length - 1) { answer.push(tempArr) } } } return answer.map(arr =&gt; arr.join(''))}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%B9%84%EB%B0%80%EC%A7%80%EB%8F%84/"},{"title":"[프로그래머스] 소수 만들기","text":"주어진 숫자 중 3개의 수를 더했을 때 소수가 되는 경우의 개수를 구하려고 합니다. 숫자들이 들어있는 배열 nums가 매개변수로 주어질 때, nums에 있는 숫자들 중 서로 다른 3개를 골라 더했을 때 소수가 되는 경우의 개수를 return 하도록 solution 함수를 완성해주세요. 제한사항 nums에 들어있는 숫자의 개수는 3개 이상 50개 이하입니다. nums의 각 원소는 1 이상 1,000 이하의 자연수이며, 중복된 숫자가 들어있지 않습니다.입출력 예 nums result [1,2,3,4] 1 [1,2,7,6,4] 4 입출력 예 설명입출력 예 #1[1,2,4]를 이용해서 7을 만들 수 있습니다. 입출력 예 #2[1,2,4]를 이용해서 7을 만들 수 있습니다.[1,4,6]을 이용해서 11을 만들 수 있습니다.[2,4,7]을 이용해서 13을 만들 수 있습니다.[4,6,7]을 이용해서 17을 만들 수 있습니다. 풀이먼저 3개의 수의 합의 경우의 수를 구해준다.그리고 합 중 가장 큰 수만큼의 에라토스테네의 체를 만들어 준다.그리고 경우의 수의 합에서 소수 인 부분을 count해주면 된다. 코드function solution(nums) { let numbers = [] let count = 0 for (let i = 0; i &lt; nums.length; i++) { let number = [] for (let j = i + 1; j &lt; nums.length; j++) { for (let k = j + 1; k &lt; nums.length; k++) { number = [nums[i], nums[j], nums[k]] numbers.push(number) } } } const sumOfNum = numbers.map(arr =&gt; arr.reduce((acc, cur) =&gt; acc + cur)) const max = Math.max.apply(null, sumOfNum) const initArr = Array(max + 1).fill(true).fill(false, 0, 2) for (let i = 2; i * i &lt;= max; i++) { if (initArr[i]) { for (let j = i * i; j &lt;= max; j += i) { initArr[j] = false } } } for (let i = 1; i &lt;= max; i++) { if (sumOfNum.includes(i) &amp;&amp; initArr[i]) { count = count + sumOfNum.filter(x =&gt; x === i).length } } return count}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%86%8C%EC%88%98-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"title":"[프로그래머스] 소수찾기","text":"1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요. 소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다.(1은 소수가 아닙니다.) 제한사항 n은 2이상 1000000이하의 자연수입니다. 입출력 예 n result 10 4 5 3 입출력 예 설명입출력 예 #11부터 10 사이의 소수는 [2,3,5,7] 4개가 존재하므로 4를 반환 입출력 예 #21부터 5 사이의 소수는 [2,3,5] 3개가 존재하므로 3를 반환 풀이알고리즘 풀면 전통적으로 나오는 소수찾기이다.소수 찾는 것 자체는 어려운게 아닌데, 속도가 문제다. 알고리즘에 따라 속도차이가 크게 난다. 그 중 제일 좋은 알고리즘이 에라토스테네스의 체이다.체라는 말 그대로 소수가 아닌 수를 체로 거르는 방식으로 계산된다.n+1만큼의 빈 배열을 만든 후에, 배수인 수를 차례로 false로 만들면, 최종 true인 소수가 남는다. 코드function solution(n) { let arr = Array(n + 1).fill(true).fill(false, 0, 2); for (let i = 2; i * i &lt;= n; i++) { if (arr[i]) { for (let j = i * i; j &lt;= n; j += i) { arr[j] = false; } } } return arr.filter(e =&gt; e).length;}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%86%8C%EC%88%98%EC%B0%BE%EA%B8%B0/"},{"title":"[프로그래머스] 숫자게임","text":"xx 회사의 2xN명의 사원들은 N명씩 두 팀으로 나눠 숫자 게임을 하려고 합니다. 두 개의 팀을 각각 A팀과 B팀이라고 하겠습니다. 숫자 게임의 규칙은 다음과 같습니다. 먼저 모든 사원이 무작위로 자연수를 하나씩 부여받습니다. 각 사원은 딱 한 번씩 경기를 합니다. 각 경기당 A팀에서 한 사원이, B팀에서 한 사원이 나와 서로의 수를 공개합니다. 그때 숫자가 큰 쪽이 승리하게 되고, 승리한 사원이 속한 팀은 승점을 1점 얻게 됩니다. 만약 숫자가 같다면 누구도 승점을 얻지 않습니다. 전체 사원들은 우선 무작위로 자연수를 하나씩 부여받았습니다. 그다음 A팀은 빠르게 출전순서를 정했고 자신들의 출전 순서를 B팀에게 공개해버렸습니다. B팀은 그것을 보고 자신들의 최종 승점을 가장 높이는 방법으로 팀원들의 출전 순서를 정했습니다. 이때의 B팀이 얻는 승점을 구해주세요.A 팀원들이 부여받은 수가 출전 순서대로 나열되어있는 배열 A와 i번째 원소가 B팀의 i번 팀원이 부여받은 수를 의미하는 배열 B가 주어질 때, B 팀원들이 얻을 수 있는 최대 승점을 return 하도록 solution 함수를 완성해주세요. 제한사항 A와 B의 길이는 같습니다. A와 B의 길이는 1 이상 100,000 이하입니다. A와 B의 각 원소는 1 이상 1,000,000,000 이하의 자연수입니다. 입출력 예 A B result [5,1,3,7] [2,2,6,8] 3 [2,2,2,2] [1,1,1,1] 0 입출력 예 설명입출력 예 #1 A 팀은 숫자 5를 부여받은 팀원이 첫번째로 출전하고, 이어서 1,3,7을 부여받은 팀원들이 차례대로 출전합니다.B 팀원들을 4번, 2번, 3번, 1번의 순서대로 출전시킬 경우 팀원들이 부여받은 숫자들은 차례대로 8,2,6,2가 됩니다. 그러면, 첫 번째, 두 번째, 세 번째 경기에서 승리하여 3점을 얻게 되고, 이때가 최대의 승점입니다. 입출력 예 #2B 팀원들을 어떤 순서로 출전시켜도 B팀의 승점은 0점입니다. 풀이효율성 테스트에서 애먹은 문제이다.splice같은 함수를 사용하면, 효율성 테스트에서 무조건 시간초과뜨기 때문에, index로 접근해서 구해줬다. 코드function solution(A, B) { A = A.sort((a, b) =&gt; a - b) B = B.sort((a, b) =&gt; a - b) let answer = 0 let aIndex = 0 let bIndex = 0 for (let i = 0; i &lt; A.length; i++) { if (A[aIndex] &gt;= B[bIndex]) { bIndex++ } else { aIndex++ bIndex++ answer++ } } return answer}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%88%AB%EC%9E%90%EA%B2%8C%EC%9E%84/"},{"title":"[프로그래머스] 숫자의 표현","text":"Finn은 요즘 수학공부에 빠져 있습니다. 수학 공부를 하던 Finn은 자연수 n을 연속한 자연수들로 표현 하는 방법이 여러개라는 사실을 알게 되었습니다. 예를들어 15는 다음과 같이 4가지로 표현 할 수 있습니다. 1 + 2 + 3 + 4 + 5 = 15 4 + 5 + 6 = 15 7 + 8 = 15 15 = 15 자연수 n이 매개변수로 주어질 때, 연속된 자연수들로 n을 표현하는 방법의 수를 return하는 solution를 완성해주세요. 제한사항 n은 10,000 이하의 자연수 입니다. 입출력 예 n result 15 4 풀이연속된 숫자의 합으로 n이 되는지 구하면 된다.sum이 n보다 커지면 그 이후의 숫자의 연속의 합은 n보다 커지기 때문에 break문을 걸어야한다. 코드function solution(n) { let answer = 0 for (let i = 1; i &lt;= n; i++) { let sum = 0 for (let j = i; j &lt;= n; j++) { sum = sum + j if (sum === n) { answer++ break } if (sum &gt; n) { break; } } } return answer}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%88%AB%EC%9E%90%EC%9D%98%ED%91%9C%ED%98%84/"},{"title":"[프로그래머스] 스킬트리","text":"선행 스킬이란 어떤 스킬을 배우기 전에 먼저 배워야 하는 스킬을 뜻합니다. 예를 들어 선행 스킬 순서가 스파크 → 라이트닝 볼트 → 썬더일때, 썬더를 배우려면 먼저 라이트닝 볼트를 배워야 하고, 라이트닝 볼트를 배우려면 먼저 스파크를 배워야 합니다. 위 순서에 없는 다른 스킬(힐링 등)은 순서에 상관없이 배울 수 있습니다. 따라서 스파크 → 힐링 → 라이트닝 볼트 → 썬더와 같은 스킬트리는 가능하지만, 썬더 → 스파크나 라이트닝 볼트 → 스파크 → 힐링 → 썬더와 같은 스킬트리는 불가능합니다. 선행 스킬 순서 skill과 유저들이 만든 스킬트리를 담은 배열 skill_trees가 매개변수로 주어질 때, 가능한 스킬트리 개수를 return 하는 solution 함수를 작성해주세요. 제한사항 스킬은 알파벳 대문자로 표기하며, 모든 문자열은 알파벳 대문자로만 이루어져 있습니다. 스킬 순서와 스킬트리는 문자열로 표기합니다. 예를 들어, C → B → D 라면 CBD로 표기합니다 선행 스킬 순서 skill의 길이는 1 이상 26 이하이며, 스킬은 중복해 주어지지 않습니다. skill_trees는 길이 1 이상 20 이하인 배열입니다. skill_trees의 원소는 스킬을 나타내는 문자열입니다. skill_trees의 원소는 길이가 2 이상 26 이하인 문자열이며, 스킬이 중복해 주어지지 않습니다. 입출력 예 skill skill_trees return “CBD” [“BACDE”, “CBADF”, “AECB”, “BDA”] 2 입출력 예 설명 BACDE: B 스킬을 배우기 전에 C 스킬을 먼저 배워야 합니다. 불가능한 스킬트립니다. CBADF: 가능한 스킬트리입니다. AECB: 가능한 스킬트리입니다. BDA: B 스킬을 배우기 전에 C 스킬을 먼저 배워야 합니다. 불가능한 스킬트리입니다. 풀이중요한 것은 CBD가 주어졌으면 CBD순서대로 잘 들어 있는지 체크하는 문제다.주어지는 skill_trees가 어떤 것이 주어지든지 CDB외에는 필요없다.그래서 skill_trees에서 CBD를 제외한 나머지를 제거해준다.그리고 CBD가 있다면 제일 먼저 C가 나와야 하기 때문에 C가 있는지 확인하고 문자열 비교 include를 이용해서 일치하면 제대로 된 스킬트리이다. 코드function solution(skill, skill_trees) { skill = skill.split('') const filteredTree = skill_trees.map(tree =&gt; { tree = tree.split('') return tree.filter(x =&gt; skill.includes(x)).join('') }) return filteredTree.map(tree =&gt; { if (tree === '') { return true } else { return (skill.join('').includes(tree) &amp;&amp; tree[0] === skill[0]) } }).filter(x =&gt; x).length}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%8A%A4%ED%82%AC%ED%8A%B8%EB%A6%AC/"},{"title":"[프로그래머스] 시저 암호","text":"어떤 문장의 각 알파벳을 일정한 거리만큼 밀어서 다른 알파벳으로 바꾸는 암호화 방식을 시저 암호라고 합니다. 예를 들어 AB는 1만큼 밀면 BC가 되고, 3만큼 밀면 DE가 됩니다. z는 1만큼 밀면 a가 됩니다. 문자열 s와 거리 n을 입력받아 s를 n만큼 민 암호문을 만드는 함수, solution을 완성해 보세요. 제한 조건 공백은 아무리 밀어도 공백입니다. s는 알파벳 소문자, 대문자, 공백으로만 이루어져 있습니다. s의 길이는 8000이하입니다. n은 1 이상, 25이하인 자연수입니다. 입출력 예 s n result AB 1 BC z 1 a a B z 4 e F d 풀이아스키코드로 풀면 된다.대문자라면 6590, 소문자라면 97122 이다. 적절하게 n을 더해서 아스키코드를 다시 문자열로 변환해주면 된다. 코드function solution(s, n) { const arr = s.split('') const asci = arr.map((char) =&gt; { const toAscii = char.charCodeAt(0) if (char === ' ') return ' ' if (toAscii &gt;= 65 &amp;&amp; toAscii &lt;= 90) { if (toAscii + n &gt; 90) return toAscii + n - 26 else return toAscii + n } if (toAscii &gt;= 97 &amp;&amp; toAscii &lt;= 122) { if (toAscii + n &gt; 122) return toAscii + n - 26 else return toAscii + n } }) return asci .map((asc) =&gt; { if (asc !== ' ') return String.fromCharCode(asc) else return ' ' }).join('')}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%8B%9C%EC%A0%80%EC%95%94%ED%98%B8/"},{"title":"[프로그래머스] 실패율","text":"슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다. 이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라. 실패율은 다음과 같이 정의한다. 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수 전체 스테이지의 개수 N, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 stages가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하도록 solution 함수를 완성하라. 제한사항 스테이지의 개수 N은 1 이상 500 이하의 자연수이다. stages의 길이는 1 이상 200,000 이하이다. stages에는 1 이상 N + 1 이하의 자연수가 담겨있다. 각 자연수는 사용자가 현재 도전 중인 스테이지의 번호를 나타낸다. 단, N + 1 은 마지막 스테이지(N 번째 스테이지) 까지 클리어 한 사용자를 나타낸다. 만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지가 먼저 오도록 하면 된다. 스테이지에 도달한 유저가 없는 경우 해당 스테이지의 실패율은 0 으로 정의한다. 입출력 예 N stages result 5 [2, 1, 2, 6, 2, 4, 3, 3] [3,4,2,1,5] 4 [4,4,4,4,4] [4,1,2,3] 입출력 예 설명입출력 예 #11번 스테이지에는 총 8명의 사용자가 도전했으며, 이 중 1명의 사용자가 아직 클리어하지 못했다. 따라서 1번 스테이지의 실패율은 다음과 같다. 1 번 스테이지 실패율 : 1/8 2번 스테이지에는 총 7명의 사용자가 도전했으며, 이 중 3명의 사용자가 아직 클리어하지 못했다. 따라서 2번 스테이지의 실패율은 다음과 같다. 2 번 스테이지 실패율 : 3/7 마찬가지로 나머지 스테이지의 실패율은 다음과 같다. 3 번 스테이지 실패율 : 2/4 4번 스테이지 실패율 : 1/2 5번 스테이지 실패율 : 0/1 각 스테이지의 번호를 실패율의 내림차순으로 정렬하면 다음과 같다. [3,4,2,1,5] 입출력 예 #2모든 사용자가 마지막 스테이지에 있으므로 4번 스테이지의 실패율은 1이며 나머지 스테이지의 실패율은 0이다. [4,1,2,3] 풀이stage는 {stage: 몇 번째, rate: 실패율}로 재정의 해준다.stage의 rate별로 내림차순을 해주고, stage단계를 리턴해주면 된다. 코드function solution(N, stages) { let stageState = [] for (let i = 1; i &lt;= N; i++) { const stage = { state: i, rate: stages.filter(x =&gt; x === i).length / stages.filter(x =&gt; x &gt;= i).length } stageState.push(stage) } return stageState.sort((a, b) =&gt; b.rate - a.rate).map(a =&gt; a.state)}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%8B%A4%ED%8C%A8%EC%9C%A8/"},{"title":"[프로그래머스] 약수의 합","text":"정수 n을 입력받아 n의 약수를 모두 더한 값을 리턴하는 함수, solution을 완성해주세요. 제한사항 n은 0 이상 3000이하인 정수입니다. 입출력 예 n return 12 28 5 6 입출력 예 설명입출력 예 #112의 약수는 1, 2, 3, 4, 6, 12입니다. 이를 모두 더하면 28입니다. 입출력 예 #25의 약수는 1, 5입니다. 이를 모두 더하면 6입니다. 풀이약수는 나누어서 0이 되면 된다. for문으로 돌면서 나머지가 0이되면 push해준다. 코드function solution(n) { let answer = [] if (n === 0) return 0 for (let i = 1; i &lt;= n; i++) { if (n % i === 0) answer.push(i) } return answer.reduce((acc, cur) =&gt; acc + cur)}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%95%BD%EC%88%98%EC%9D%98-%ED%95%A9/"},{"title":"[프로그래머스] 예산","text":"S사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다. 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다. 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다. 물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다. 예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다. 부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 solution 함수를 완성해주세요. 제한사항 d는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수)는 1 이상 100 이하입니다. d의 각 원소는 부서별로 신청한 금액을 나타내며, 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다. budget은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다. 입출력 예 d budget result [1,3,2,5,4] 9 3 [2,2,3,3] 10 4 입출력 예 설명입출력 예 #1각 부서에서 [1원, 3원, 2원, 5원, 4원]만큼의 금액을 신청했습니다. 만약에, 1원, 2원, 4원을 신청한 부서의 물품을 구매해주면 예산 9원에서 7원이 소비되어 2원이 남습니다. 항상 정확히 신청한 금액만큼 지원해 줘야 하므로 남은 2원으로 나머지 부서를 지원해 주지 않습니다. 위 방법 외에 3개 부서를 지원해 줄 방법들은 다음과 같습니다. 1원, 2원, 3원을 신청한 부서의 물품을 구매해주려면 6원이 필요합니다. 1원, 2원, 5원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다. 1원, 3원, 4원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다. 1원, 3원, 5원을 신청한 부서의 물품을 구매해주려면 9원이 필요합니다. 3개 부서보다 더 많은 부서의 물품을 구매해 줄 수는 없으므로 최대 3개 부서의 물품을 구매해 줄 수 있습니다. 입출력 예 #2모든 부서의 물품을 구매해주면 10원이 됩니다. 따라서 최대 4개 부서의 물품을 구매해 줄 수 있습니다. 풀이모든 경우의 수를 따져봐야 할 것 같지만, 최대로 줄 수 있는 부서의 수를 구하는 것이기 때문에, 작은 예산을 요구하는 부서 순서대로 지원해주면 제일 많이 지원할 수 있다.주어진 부서d를 오름차순으로 정렬해준 뒤에, budget을 초과하기 전까지 더해주면 된다. 코드function solution(d, budget) { d.sort((a,b) =&gt; a - b) let total = 0 let count = 0 for (let i = 0; i &lt; d.length; i++) { count++ total += d[i] if (total &gt; budget) { count-- break } } return count}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%98%88%EC%82%B0/"},{"title":"[프로그래머스] 올바른 괄호","text":"괄호가 바르게 짝지어졌다는 것은 ‘(‘ 문자로 열렸으면 반드시 짝지어서 ‘)’ 문자로 닫혀야 한다는 뜻입니다. 예를 들어 ()() 또는 (())() 는 올바른 괄호입니다. )()( 또는 (()( 는 올바르지 않은 괄호입니다. ‘(‘ 또는 ‘)’ 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 return 하고, 올바르지 않은 괄호이면 false를 return 하는 solution 함수를 완성해 주세요. 제한사항 문자열 s의 길이 : 100,000 이하의 자연수 문자열 s는 ‘(‘ 또는 ‘)’ 로만 이루어져 있습니다.입출력 예 s answer ()() true (())() true )()( false (()( false 입출력 예 설명먼저 올바른 괄호가 아닌 경우에 먼저 체크해줍니다. )이 먼저 나오면 false (이 마지막에 나오면 false (의 개수와 )의 개수가 다르면 false그리고 괄호를 체크해 줍니다. (이면 +1, )이면 -1을 해줍니다.음수가 되면 괄호가 맞지 않은 것이기 때문에 false입니다.ex) (())() 풀이코드function solution(s) { const toArr = s.split('') const right = toArr.filter(value =&gt; value === '(') const left = toArr.filter(value =&gt; value === ')') if (toArr[toArr.length - 1] === '(') return false if (toArr[0] === ')') return false if (right.length !== left.length) return false let check = 0 for (let i = 0; i &lt; toArr.length; i++) { if (toArr[i] === '(') check++ if (toArr[i] === ')') check-- if (check &lt; 0) return false } return true}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%98%AC%EB%B0%94%EB%A5%B8%EA%B4%84%ED%98%B8/"},{"title":"프로그래머스-완주하지 못한 선수","text":"수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요. 제한사항 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다. completion의 길이는 participant의 길이보다 1 작습니다. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다. 참가자 중에는 동명이인이 있을 수 있습니다. 입출력 예 participant completion return [leo, kiki, eden] [eden, kiki] leo [marina, josipa, nikola, vinko, filipa] [josipa, filipa, marina, nikola] vinko [mislav, stanko, mislav, ana] [stanko, ana, mislav] mislav 입출력 예 설명예제 #1leo는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #2vinko는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #3mislav는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다. 풀이어렵게 푸는 문제가 아니였다.처음에 하나씩 매치시키면서 제거하는 방식으로 풀었으나, 효율성 통과를 하지 못했다.완주 못한 선수는 한명이기 때문에 참여자와 완주자를 비교해서 다른 부분을 찾으면 된다. participant와 completion을 정렬해준다. for문으로 비교하면서 다르면 return 코드function solution(participant, completion) { participant.sort() completion.sort() for (let i = 0; i &lt; participant.length; i++) { if (completion[i] !== participant[i]) return participant[i] }}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%99%84%EC%A3%BC%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%9C-%EC%84%A0%EC%88%98/"},{"title":"[프로그래머스] 위장","text":"스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다. 예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다. 종류 이름 얼굴 동그란 안경, 검정 선글라스 상의 파란색 티셔츠 하의 청바지 겉옷 긴 코트 스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요. 제한사항 clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다. 스파이가 가진 의상의 수는 1개 이상 30개 이하입니다. 같은 이름을 가진 의상은 존재하지 않습니다. clothes의 모든 원소는 문자열로 이루어져 있습니다. 모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 ‘_’ 로만 이루어져 있습니다. 스파이는 하루에 최소 한 개의 의상은 입습니다. 입출력 예 clothes return [[yellow_hat, headgear], [blue_sunglasses, eyewear], [green_turban, headgear]] 5 [[crow_mask, face], [blue_sunglasses, face], [smoky_makeup, face]] 3 입출력 예 설명예제 #1headgear에 해당하는 의상이 yellow_hat, green_turban이고 eyewear에 해당하는 의상이 blue_sunglasses이므로 아래와 같이 5개의 조합이 가능합니다. 1. yellow_hat2. blue_sunglasses3. green_turban4. yellow_hat + blue_sunglasses5. green_turban + blue_sunglasses 예제 #2face에 해당하는 의상이 crow_mask, blue_sunglasses, smoky_makeup이므로 아래와 같이 3개의 조합이 가능합니다. 1. crow_mask2. blue_sunglasses3. smoky_makeup 풀이경우의 수를 구하는 문제이다.모든 경우의 수를 알고리즘으로 푸는 것보다 수학적으로 접근하면 쉽게 풀 수 있다. 먼저 어떤 종류가 있는지 구한다. 해당 종류에 몇 가지가 있는지 구한다. (옷의 종류) * (종류의 가짓 수) - 1(마지막에 -1을 하는 것은 아무것도 안 입었을 때의 경우의 수이다.) 코드function solution(clothes) { const TYPE = Array(...new Set(clothes.map(value =&gt; value[1]))) let answer = [] for (let i = 0; i &lt; TYPE.length; i++) { answer.push(clothes.filter(value =&gt; value[1] === TYPE[i])) } return answer.map(arr =&gt; arr.length).reduce((acc, cur) =&gt; acc * (cur + 1), 1) - 1}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%9C%84%EC%9E%A5/"},{"title":"[프로그래머스] 이상한문자만들기","text":"문자열 s는 한 개 이상의 단어로 구성되어 있습니다. 각 단어는 하나 이상의 공백문자로 구분되어 있습니다. 각 단어의 짝수번째 알파벳은 대문자로, 홀수번째 알파벳은 소문자로 바꾼 문자열을 리턴하는 함수, solution을 완성하세요. 제한사항 문자열 전체의 짝/홀수 인덱스가 아니라, 단어(공백을 기준)별로 짝/홀수 인덱스를 판단해야합니다. 첫 번째 글자는 0번째 인덱스로 보아 짝수번째 알파벳으로 처리해야 합니다. 입출력 예 s return try hello world TrY HeLlO WoRlD 입출력 예 설명try hello world는 세 단어 try, hello, world로 구성되어 있습니다. 각 단어의 짝수번째 문자를 대문자로, 홀수번째 문자를 소문자로 바꾸면 TrY, HeLlO, WoRlD입니다. 따라서 TrY HeLlO WoRlD 를 리턴합니다. 풀이빈칸을 기준으로 split해준뒤, index가 짝수면 대문자로 바꿔주고 아니면 소문자로 변환해주면 된다. 코드function solution(s) { return s .toLowerCase() .split(' ') .map(word =&gt; word.split('') .map((char, index) =&gt; index % 2 === 0 ? char.toUpperCase() : char) .join('')) .join(' ')}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%9D%B4%EC%83%81%ED%95%9C%EB%AC%B8%EC%9E%90%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"title":"[프로그래머스] 이중우선순위큐","text":"이중 우선순위 큐는 다음 연산을 할 수 있는 자료구조를 말합니다. 명령어 수신 탑(높이) I 숫자 큐에 주어진 숫자를 삽입합니다. D 1 큐에서 최댓값을 삭제합니다. D -1 큐에서 최솟값을 삭제합니다. 이중 우선순위 큐가 할 연산 operations가 매개변수로 주어질 때, 모든 연산을 처리한 후 큐가 비어있으면 [0,0] 비어있지 않으면 [최댓값, 최솟값]을 return 하도록 solution 함수를 구현해주세요. 제한사항 operations는 길이가 1 이상 1,000,000 이하인 문자열 배열입니다. operations의 원소는 큐가 수행할 연산을 나타냅니다. 원소는 “명령어 데이터” 형식으로 주어집니다.- 최댓값/최솟값을 삭제하는 연산에서 최댓값/최솟값이 둘 이상인 경우, 하나만 삭제합니다. 빈 큐에 데이터를 삭제하라는 연산이 주어질 경우, 해당 연산은 무시합니다. 입출력 예 operations return [‘I 16’, ‘D 1’] [0,0] [‘I 7’, ‘I 5’, ‘I -5’, ‘D -1’] [7,5] 입출력 예 설명16을 삽입 후 최댓값을 삭제합니다. 비어있으므로 [0,0]을 반환합니다.7,5,-5를 삽입 후 최솟값을 삭제합니다. 최대값 7, 최소값 5를 반환합니다. 풀이lv3라고 해서 어려울 줄 알았는데 별로 어렵지 않았다.operation의 조건을 잘 설정해서 연산해주면 된다. 코드function solution(operations) { let answer = [] for (let i = 0; i &lt; operations.length; i++) { const operation = operations[i].split(' ') if (operation[0] === 'I') { answer.push(+operation[1]) } if (operation[0] === 'D') { let index = null if (operation[1] === '1') { const max = Math.max.apply(null, answer) index = answer.indexOf(max) } if (operation[1] === '-1') { const min = Math.min.apply(null, answer) index = answer.indexOf(min) } answer.splice(index, 1) } } return answer.length === 0 ? [0, 0] : [Math.max.apply(null, answer), Math.min.apply(null, answer)]}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%9D%B4%EC%A4%91%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%ED%81%90/"},{"title":"[프로그래머스] 체육복","text":"점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다. 전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요. 제한사항 전체 학생의 수는 2명 이상 30명 이하입니다. 체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다. 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다. 입출력 예 n lost reserve return 5 [2, 4] [1, 3, 5] 5 5 [2, 4] [3] 4 3 [3] [1] 2 입출력 예 설명예제 #11번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다. 예제 #23번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다. 풀이먼저 체육복을 누가 얼마나 갖고 있는지 배열로 만들어준다.예제 1) [2,0,2,0,2]loop돌면서 0이라면 앞 뒤로 2가 있다면 +1, 2였던 요소는 -1 해준다.마지막 1보다 큰 요소를 filter의 길이만큼 return해준다. 코드function solution(n, lost, reserve) { let answer = 0; let students = [] for (let i = 1; i &lt;= n; i++) { students.push(1) if (lost.includes(i)) { students[i - 1]-- } if (reserve.includes(i)) { students[i - 1]++ } } for (let i = 0; i &lt; n; i++) { if (!students[i]) { if (students[i - 1] === 2) { students[i]++ students[i - 1]-- } else if (students[i + 1] === 2) { students[i]++ students[i + 1]-- } } } return students.filter(value =&gt; value &gt;= 1).length}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%B2%B4%EC%9C%A1%EB%B3%B5/"},{"title":"[프로그래머스] 최대공약수와 최소공배수","text":"두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환하는 함수, solution을 완성해 보세요. 배열의 맨 앞에 최대공약수, 그다음 최소공배수를 넣어 반환하면 됩니다. 예를 들어 두 수 3, 12의 최대공약수는 3, 최소공배수는 12이므로 solution(3, 12)는 [3, 12]를 반환해야 합니다. 제한사항 두 수는 1이상 1000000이하의 자연수입니다. 입출력 예 n m return 3 12 [3, 12] 2 5 [1, 10] 입출력 예 설명입출력 예 #1위의 설명과 같습니다. 입출력 예 #2자연수 2와 5의 최대공약수는 1, 최소공배수는 10이므로 [1, 10]을 리턴해야 합니다. 풀이최대공약수를 구하면 최소공배수는 구한 최대공약수를 이용해서 쉽게 구할 수 있다.최대공약수는 재귀로 풀면 된다. 코드function solution(n, m) { return [gcd(n, m), n * m / gcd(n, m)]}function gcd(n, m) { return m === 0 ? n : gcd(m, n % m)}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98%EC%99%80-%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98/"},{"title":"프로그래머스-카펫","text":"Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다. Leo는 집으로 돌아와서 아까 본 카펫의 노란색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다. Leo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한사항 갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다. 노란색 격자의 수 yellow는 1 이상 2,000,000 이하인 자연수입니다. 카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다. 입출력 예 brown yellow return 10 2 [4, 3] 8 1 [3, 3] 24 24 [8, 6] 풀이brown + yellow는 카펫의 넓이다.yello는 최소 1이기때문에 사각형의 최소 길이는 3이다.brown + yellow에서 3을 나눈 모든 경우의 수는 brown의 길이 후보다.그 수 의 (길이 - 2) * (카펫 넓이 / 길이 - 2)가 주어진 yellow와 같다면 정답이다.가로가 세로보다 길기 때문에 sort해주면 된다. 코드function solution(brown, yellow) { const spec = brown + yellow let div = [] for (let i = 3; i &lt;= spec; i++) { if (spec % i === 0) div.push(i) } for (let el of div) { const x = el - 2 const y = spec / el - 2 if (x * y === yellow) return [el, spec / el].sort((a, b) =&gt; b - a) }}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%B9%B4%ED%8E%AB/"},{"title":"[프로그래머스] 콜라츠추측","text":"1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다. 1-1. 입력된 수가 짝수라면 2로 나눕니다. 1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다.2. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다. 예를 들어, 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번 만에 1이 됩니다. 위 작업을 몇 번이나 반복해야하는지 반환하는 함수, solution을 완성해 주세요. 단, 작업을 500번을 반복해도 1이 되지 않는다면 –1을 반환해 주세요. 제한사항 입력된 수, num은 1 이상 8000000 미만인 정수입니다. 입출력 예 n result 6 8 16 4 626331 -1 입출력 예 설명입출력 예 #1문제의 설명과 같습니다. 입출력 예 #216 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1 이되어 총 4번만에 1이 됩니다. 입출력 예 #3626331은 500번을 시도해도 1이 되지 못하므로 -1을 리턴해야합니다. 풀이조건에 맞춰서 하나씩 풀어나가면 된다.while문을 이용해서 조건 맞춰서 진행하면 된다. 코드function solution(num) { let cnt = 0 while (num !== 1) { cnt++ if (num % 2 === 0) { num = num / 2 } else ( num = num * 3 + 1 ) if (cnt === 500) { return -1 } } return cnt}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%BD%9C%EB%9D%BC%EC%B8%A0%EC%B6%94%EC%B8%A1/"},{"title":"[프로그래머스] 큰 수 만들기","text":"어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다. 예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다. 문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요. 제한사항 number는 1자리 이상, 1,000,000자리 이하인 숫자입니다. k는 1 이상 number의 자릿수 미만인 자연수입니다. 입출력 예 number k return 1924 2 94 1231234 3 3234 4177252841 4 775841 풀이첫번째 자릿수가 커야 가장 큰 수 이다.answer에 마지막 요소와 number를 비교하면서 answer보다 number가 크면 pop해주고 제거할 수 있는 횟수 k를 -1해준다. 코드function solution(number, k) { let answer = [] for (let i = 0; i &lt; number.length; i++) { const num = number[i] while (k &gt; 0 &amp;&amp; answer[answer.length - 1] &lt; num) { answer.pop() k-- } answer.push(num) } return answer.join('').slice(0, number.length - k)}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%81%B0-%EC%88%98-%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"title":"[프로그래머스] 피보나치 수","text":"피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다. F(2) = F(0) + F(1) = 0 + 1 = 1 F(3) = F(1) + F(2) = 1 + 1 = 2 F(4) = F(2) + F(3) = 1 + 2 = 3 F(5) = F(3) + F(4) = 2 + 3 = 5 와 같이 이어집니다. 2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요 제한사항 n은 1이상, 100000이하인 자연수입니다. 입출력 예 n return 3 2 5 5 풀이피보나치 수열은 숫자가 조금만 커져도 엄청나게 커져서 무조건 시간초과가 뜹니다.그래서 행렬로 풀이하는 방법으로 해결합니다. 코드function solution(n) { let result = [[1, 1], [1, 0]] for (let i = 1; i &lt;= n; i++) { result = pow(result) } return result[1][1]}function pow(arr) { const baseArr = [[1, 1], [1, 0]] const x = (baseArr[0][0] * arr[0][0] + baseArr[0][1] * arr[1][0]) % 1234567 const y = (baseArr[0][0] * arr[0][1] + baseArr[0][1] * arr[1][1]) % 1234567 const z = (baseArr[1][0] * arr[0][0] + baseArr[1][1] * arr[1][0]) % 1234567 const k = (baseArr[1][0] * arr[0][1] + baseArr[1][1] * arr[1][1]) % 1234567 return [[x, y], [z, k]]}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98%EC%88%98/"},{"title":"[프로그래머스] 하샤드 수","text":"양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다. 예를 들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다. 자연수 x를 입력받아 x가 하샤드 수인지 아닌지 검사하는 함수, solution을 완성해주세요. 제한사항 x는 1 이상, 10000 이하인 정수입니다. 입출력 예 arr return 10 true 12 true 11 false 13 false 입출력 예 설명입출력 예 #110의 모든 자릿수의 합은 1입니다. 10은 1로 나누어 떨어지므로 10은 하샤드 수입니다. 입출력 예 #212의 모든 자릿수의 합은 3입니다. 12는 3으로 나누어 떨어지므로 12는 하샤드 수입니다. 입출력 예 #311의 모든 자릿수의 합은 2입니다. 11은 2로 나누어 떨어지지 않으므로 11는 하샤드 수가 아닙니다. 입출력 예 #413의 모든 자릿수의 합은 4입니다. 13은 4로 나누어 떨어지지 않으므로 13은 하샤드 수가 아닙니다. 풀이x는 숫자이기 때문에 자릿수로 쪼개기 위해서 String으로 변환해준다. reduce로 자릿수를 더하고 조건에 따라 True, False를 return 코드function solution(x) { return x % String(x).split('').reduce((a, b) =&gt; a / 1 + b / 1) === 0 ? true : false}","link":"/2020/10/24/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%95%98%EC%83%A4%EB%93%9C-%EC%88%98/"},{"title":"test","text":"This is test ttt","link":"/2020/12/12/test/"}],"tags":[{"name":"tutorial","slug":"tutorial","link":"/tags/tutorial/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"wsl","slug":"wsl","link":"/tags/wsl/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"python","slug":"python","link":"/tags/python/"}],"categories":[{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Typescript","slug":"Typescript","link":"/categories/Typescript/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"프로그래머스","slug":"Algorithm/프로그래머스","link":"/categories/Algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"}]}